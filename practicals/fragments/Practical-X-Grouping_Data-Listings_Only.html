<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Preamble â€“ Foundations of Spatial Data Science</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../..//img/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-fb446d74831b8ff67c69632cb314b545.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c734b2b4d74e7e594e143a63449c09f7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<meta property="og:title" content="Preamble â€“ Foundations of Spatial Data Science">
<meta property="og:description" content="">
<meta property="og:image" content="img/logo/full_sm.png">
<meta property="og:site_name" content="Foundations">
<meta property="og:locale" content="en_GB">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-md " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../img/logo/logo_only_sm.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Foundations of Spatial Data Science</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../setup/index.html"> 
<span class="menu-text">Setup</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-week-by-week" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Week-by-Week</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-week-by-week">    
        <li>
    <a class="dropdown-item" href="../../sessions/index.html">
 <span class="dropdown-text">Overview</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">Part 1: Foundations</li>
        <li>
    <a class="dropdown-item" href="../../sessions/week1.html">
 <span class="dropdown-text">1. Setting Up</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../sessions/week2.html">
 <span class="dropdown-text">2. Foundations (Pt.1)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../sessions/week3.html">
 <span class="dropdown-text">3. Foundations (Pt.2)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../sessions/week4.html">
 <span class="dropdown-text">4. Efficient Code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../sessions/week5.html">
 <span class="dropdown-text">5. Objects</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../sessions/reading_week.html">
 <span class="dropdown-text">Reading Week</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">Part 2: Process</li>
        <li>
    <a class="dropdown-item" href="../../sessions/week6.html">
 <span class="dropdown-text">6. Numeric Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../sessions/week7.html">
 <span class="dropdown-text">7. Spatial Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../sessions/week8.html">
 <span class="dropdown-text">8. Textual Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../sessions/week9.html">
 <span class="dropdown-text">9. Selecting Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../sessions/week10.html">
 <span class="dropdown-text">10. Presenting Data</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">Part 3: Bonus</li>
        <li>
    <a class="dropdown-item" href="../../sessions/week11.html">
 <span class="dropdown-text">11. Dimensions in Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../sessions/week12.html">
 <span class="dropdown-text">12. Grouping Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../references.html">
 <span class="dropdown-text">Bibliography</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-assessments" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Assessments</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-assessments">    
        <li>
    <a class="dropdown-item" href="../../assessments/index.html">
 <span class="dropdown-text">Overview</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">Elements</li>
        <li>
    <a class="dropdown-item" href="../../assessments/exam.html">
 <span class="dropdown-text">Timed Open Book Exam</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../assessments/group.html">
 <span class="dropdown-text">Group Work</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../assessments/peer.html">
 <span class="dropdown-text">Group Self-Evaluation</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../help.html"> 
<span class="menu-text">Getting Help</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    <div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="Practical-X-Grouping_Data-Listings_Only.ipynb" download="Practical-X-Grouping_Data-Listings_Only.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li><li><a href="Practical-X-Grouping_Data-Listings_Only.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Preamble</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 32%">
<col style="width: 20%">
<col style="width: 27%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Complete</th>
<th style="text-align: left;">Part 1: Foundations</th>
<th style="text-align: left;">Part 2: Data</th>
<th style="text-align: left;">Part 3: Analysis</th>
<th style="text-align: right;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">90%</td>
<td style="text-align: left;">â–“â–“â–“â–“â–“â–“â–“â–“</td>
<td style="text-align: left;">â–“â–“â–“â–“â–“â–“</td>
<td style="text-align: left;">â–“â–“â–“â–“â–“â–‘</td>
<td style="text-align: right;">10/10</td>
</tr>
</tbody>
</table>
<p>A common challenge in data analysis is how to group observations in a data set together in a way that allows for generalisation: <em>this</em> group of observations are similar to one another, <em>that</em> group is dissimilar to this group. But what defines similarity and difference? There is no <em>one</em> answer to that question and so there are many different ways to cluster data, each of which has strengths and weaknesses that make them more, or less, appropriate in different contexts.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>ðŸ”— Connections</strong>:</p>
</div>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="im">import</span> matplotlib.cm <span class="im">as</span> cm</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="im">import</span> requests</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="im">import</span> zipfile</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="im">import</span> re</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="im">import</span> os</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="im">import</span> pickle <span class="im">as</span> pk</span>
<span id="cb1-12"><a href="#cb1-12"></a></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="im">from</span> io <span class="im">import</span> BytesIO, StringIO</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="im">from</span> os.path <span class="im">import</span> join <span class="im">as</span> pj</span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="im">from</span> matplotlib.colors <span class="im">import</span> ListedColormap</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="im">import</span> sklearn</span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="im">from</span> sklearn.neighbors <span class="im">import</span> NearestNeighbors</span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> TSNE</span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> PowerTransformer, RobustScaler, StandardScaler</span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans, DBSCAN, OPTICS</span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="im">from</span> esda.adbscan <span class="im">import</span> ADBSCAN</span>
<span id="cb1-26"><a href="#cb1-26"></a></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="im">import</span> random</span>
<span id="cb1-28"><a href="#cb1-28"></a>random.seed(<span class="dv">42</span>)    <span class="co"># For reproducibility</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>np.random.seed(<span class="dv">42</span>) <span class="co"># For reproducibility</span></span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="co"># Make numeric display a bit neater</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>pd.set_option(<span class="st">'display.float_format'</span>, <span class="kw">lambda</span> x: <span class="st">'</span><span class="sc">{:,.2f}</span><span class="st">'</span>.<span class="bu">format</span>(x))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="load-geodata-for-display" class="level2">
<h2 class="anchored" data-anchor-id="load-geodata-for-display">Load GeoData for Display</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># Load Water GeoPackage</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>w_path <span class="op">=</span> os.path.join(<span class="st">'data'</span>,<span class="st">'geo'</span>,<span class="st">'Water.gpkg'</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(w_path):</span>
<span id="cb2-4"><a href="#cb2-4"></a>    water <span class="op">=</span> gpd.read_file(<span class="st">'https://github.com/jreades/i2p/blob/master/data/src/Water.gpkg?raw=true'</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a>    water.to_file(w_path)</span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="bu">print</span>(<span class="st">"Downloaded Water.gpkg file."</span>)</span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="cf">else</span>:</span>
<span id="cb2-8"><a href="#cb2-8"></a>    water <span class="op">=</span> gpd.read_file(w_path)</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="co"># Boroughs GeoPackage</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>b_path <span class="op">=</span> os.path.join(<span class="st">'data'</span>,<span class="st">'geo'</span>,<span class="st">'Boroughs.gpkg'</span>)</span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(b_path):</span>
<span id="cb2-13"><a href="#cb2-13"></a>    boroughs <span class="op">=</span> gpd.read_file(<span class="st">'https://github.com/jreades/i2p/blob/master/data/src/Boroughs.gpkg?raw=true'</span>)</span>
<span id="cb2-14"><a href="#cb2-14"></a>    boroughs.to_file(b_path)</span>
<span id="cb2-15"><a href="#cb2-15"></a>    <span class="bu">print</span>(<span class="st">"Downloaded Boroughs.gpkg file."</span>)</span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="cf">else</span>:</span>
<span id="cb2-17"><a href="#cb2-17"></a>    boroughs <span class="op">=</span> gpd.read_file(b_path)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="useful-functions-for-plotting" class="level4">
<h4 class="anchored" data-anchor-id="useful-functions-for-plotting">Useful Functions for Plotting</h4>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">def</span> plt_ldn(w<span class="op">=</span>water, b<span class="op">=</span>boroughs):</span>
<span id="cb3-2"><a href="#cb3-2"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">12</span>))</span>
<span id="cb3-3"><a href="#cb3-3"></a>    w.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">'#79aef5'</span>, zorder<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-4"><a href="#cb3-4"></a>    b.plot(ax<span class="op">=</span>ax, edgecolor<span class="op">=</span><span class="st">'#cc2d2d'</span>, facecolor<span class="op">=</span><span class="st">'None'</span>, zorder<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a>    ax.set_xlim([<span class="dv">502000</span>,<span class="dv">563000</span>])</span>
<span id="cb3-6"><a href="#cb3-6"></a>    ax.set_ylim([<span class="dv">155000</span>,<span class="dv">201500</span>])</span>
<span id="cb3-7"><a href="#cb3-7"></a>    ax.spines[<span class="st">'top'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb3-8"><a href="#cb3-8"></a>    ax.spines[<span class="st">'right'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb3-9"><a href="#cb3-9"></a>    ax.spines[<span class="st">'bottom'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb3-10"><a href="#cb3-10"></a>    ax.spines[<span class="st">'left'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="cf">return</span> fig, ax</span>
<span id="cb3-12"><a href="#cb3-12"></a></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="kw">def</span> default_cmap(n, outliers<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb3-14"><a href="#cb3-14"></a>    cmap <span class="op">=</span> mpl.cm.get_cmap(<span class="st">'viridis_r'</span>, n)</span>
<span id="cb3-15"><a href="#cb3-15"></a>    colors <span class="op">=</span> cmap(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,n))</span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="cf">if</span> outliers:</span>
<span id="cb3-17"><a href="#cb3-17"></a>        gray <span class="op">=</span> np.array([<span class="dv">225</span><span class="op">/</span><span class="dv">256</span>, <span class="dv">225</span><span class="op">/</span><span class="dv">256</span>, <span class="dv">225</span><span class="op">/</span><span class="dv">256</span>, <span class="dv">1</span>])</span>
<span id="cb3-18"><a href="#cb3-18"></a>        colors <span class="op">=</span> np.insert(colors, <span class="dv">0</span>, gray, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-19"><a href="#cb3-19"></a>    <span class="cf">return</span> ListedColormap(colors)</span>
<span id="cb3-20"><a href="#cb3-20"></a></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="co"># mappable = ax.collections[-1] if you add the geopandas</span></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="co"># plot last.</span></span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="kw">def</span> add_colorbar(mappable, ax, cmap, norm, breaks, outliers<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb3-24"><a href="#cb3-24"></a>    cb <span class="op">=</span> fig.colorbar(mappable, ax<span class="op">=</span>ax, cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm,</span>
<span id="cb3-25"><a href="#cb3-25"></a>                    boundaries<span class="op">=</span>breaks,</span>
<span id="cb3-26"><a href="#cb3-26"></a>                    extend<span class="op">=</span>(<span class="st">'min'</span> <span class="cf">if</span> outliers <span class="cf">else</span> <span class="st">'neither'</span>), </span>
<span id="cb3-27"><a href="#cb3-27"></a>                    spacing<span class="op">=</span><span class="st">'uniform'</span>,</span>
<span id="cb3-28"><a href="#cb3-28"></a>                    orientation<span class="op">=</span><span class="st">'horizontal'</span>,</span>
<span id="cb3-29"><a href="#cb3-29"></a>                    fraction<span class="op">=</span><span class="fl">0.05</span>, shrink<span class="op">=</span><span class="fl">0.5</span>, pad<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb3-30"><a href="#cb3-30"></a>    cb.set_label(<span class="st">"Cluster Number"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="loading-data" class="level2">
<h2 class="anchored" data-anchor-id="loading-data">Loading Data</h2>
<section id="load-the-listings-data" class="level4">
<h4 class="anchored" data-anchor-id="load-the-listings-data">Load the Listings Data</h4>
<p>Feel free to download this manually and load it locally rather that loading via the URL:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>fdf <span class="op">=</span> pd.read_csv(url, compression<span class="op">=</span><span class="st">'gzip'</span>, low_memory<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>fdf.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>fdf[fdf.host_listings_count <span class="op">==</span> <span class="dv">0</span>][[<span class="st">'host_total_listings_count'</span>,<span class="st">'calculated_host_listings_count'</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>url <span class="op">=</span> <span class="st">'https://github.com/jreades/i2p/blob/master/data/clean/2020-08-24-listings.csv.gz?raw=true'</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>df <span class="op">=</span> pd.read_csv(url, compression<span class="op">=</span><span class="st">'gzip'</span>, low_memory<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb7-3"><a href="#cb7-3"></a>                 usecols<span class="op">=</span>[<span class="st">'room_type'</span>,<span class="st">'calculated_host_listings_count'</span>,<span class="st">'availability_90'</span>,<span class="st">'availability_365'</span>,<span class="st">'longitude'</span>,<span class="st">'latitude'</span>,<span class="st">'price'</span>])</span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="bu">print</span>(<span class="ss">f"Data frame is </span><span class="sc">{</span>df<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">:,}</span><span class="ss"> x </span><span class="sc">{</span>df<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You should have: <code>Data frame is 74,120 x 7</code>.</p>
</section>
<section id="aggregating-listings-by-msoa" class="level4">
<h4 class="anchored" data-anchor-id="aggregating-listings-by-msoa">Aggregating Listings by MSOA</h4>
<p>Next, letâ€™s link all this using the MSOA Geography that we created last week and a mix or merge and sjoin!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>msoas <span class="op">=</span> gpd.read_file(os.path.join(<span class="st">'data'</span>,<span class="st">'geo'</span>,<span class="st">'London_MSOAs.gpkg'</span>), driver<span class="op">=</span><span class="st">'GPKG'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>gdf <span class="op">=</span> gpd.GeoDataFrame(df, </span>
<span id="cb9-2"><a href="#cb9-2"></a>      geometry<span class="op">=</span>gpd.points_from_xy(df[<span class="st">'longitude'</span>], df[<span class="st">'latitude'</span>], crs<span class="op">=</span><span class="st">'epsg:4326'</span>))</span>
<span id="cb9-3"><a href="#cb9-3"></a>gdf <span class="op">=</span> gdf.to_crs(<span class="st">'epsg:27700'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># ml == MSOA Listings</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>ml <span class="op">=</span> gpd.sjoin(gdf, msoas[[<span class="st">'MSOA11CD'</span>,<span class="st">'geometry'</span>]], op<span class="op">=</span><span class="st">'within'</span>).drop(columns<span class="op">=</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    [<span class="st">'latitude'</span>,<span class="st">'longitude'</span>,<span class="st">'index_right'</span>,<span class="st">'geometry'</span>]</span>
<span id="cb10-4"><a href="#cb10-4"></a>)</span>
<span id="cb10-5"><a href="#cb10-5"></a>ml <span class="op">=</span> ml[<span class="op">~</span>(ml.room_type.isin([<span class="st">'Hotel room'</span>,<span class="st">'Shared room'</span>]))]</span>
<span id="cb10-6"><a href="#cb10-6"></a>ml.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a>ax <span class="op">=</span> ml.calculated_host_listings_count.hist(bins<span class="op">=</span><span class="dv">1500</span>)</span>
<span id="cb11-2"><a href="#cb11-2"></a>ax.set_xlim([<span class="dv">0</span>,<span class="dv">50</span>])<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>ml[<span class="st">'multihost'</span>] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>ml.loc[ml.calculated_host_listings_count<span class="op">&gt;=</span><span class="dv">3</span>,<span class="st">'multihost'</span>] <span class="op">=</span> <span class="va">True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>ax <span class="op">=</span> ml.price.hist(bins<span class="op">=</span><span class="dv">5000</span>)</span>
<span id="cb13-2"><a href="#cb13-2"></a>ax.set_xlim([<span class="dv">0</span>,<span class="dv">1000</span>])<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="cf">for</span> p <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">300</span>, <span class="dv">1050</span>, <span class="dv">50</span>):</span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="bu">print</span>(<span class="ss">f"Percent of listings above $</span><span class="sc">{</span>p<span class="sc">:,}</span><span class="ss">/night: </span><span class="sc">{</span>(ml[ml.price <span class="op">&gt;</span> p].price.count() <span class="op">/</span> ml.shape[<span class="dv">0</span>])<span class="op">*</span><span class="dv">100</span><span class="sc">:0.2f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a>mlg <span class="op">=</span> ml[ml.price <span class="op">&lt;=</span> <span class="dv">700</span>].groupby(</span>
<span id="cb15-2"><a href="#cb15-2"></a>    [<span class="st">'MSOA11CD'</span>,<span class="st">'room_type'</span>,<span class="st">'multihost'</span>] </span>
<span id="cb15-3"><a href="#cb15-3"></a>)[<span class="st">'price'</span>].agg(Mean<span class="op">=</span><span class="st">'mean'</span>, Count<span class="op">=</span><span class="st">'count'</span>).reset_index()</span>
<span id="cb15-4"><a href="#cb15-4"></a>mlg.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a>rs <span class="op">=</span> RobustScaler(quantile_range<span class="op">=</span>[<span class="fl">2.5</span>,<span class="fl">97.5</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You should see wide ranges of counts by roomt type in the first MSOA alone: the largest number of listings is for Entire home/apt but there are 242 multi-host listings compared to â€˜justâ€™ 156 non-multis. I believe this is the City of London though, which is quite unusual for a MSOA and should probably be treated as an outlier in most cases.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a>mlgp <span class="op">=</span> mlg.pivot(index<span class="op">=</span><span class="st">'MSOA11CD'</span>, columns<span class="op">=</span>[<span class="st">'room_type'</span>,<span class="st">'multihost'</span>], values<span class="op">=</span>[<span class="st">'Mean'</span>,<span class="st">'Count'</span>]).reset_index().fillna(<span class="dv">0</span>)</span>
<span id="cb17-2"><a href="#cb17-2"></a>mlgp.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>mlgp[[<span class="st">'Mean'</span>]].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="cf">for</span> c <span class="kw">in</span> mlgp[[<span class="st">'Mean'</span>]].columns.values:</span>
<span id="cb19-2"><a href="#cb19-2"></a>    mlgp[c] <span class="op">=</span> rs.fit_transform(mlgp[c].values.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a>mlgp[[<span class="st">'Mean'</span>]].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>mlgp[[<span class="st">'Count'</span>]].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a>total <span class="op">=</span> mlgp[[<span class="st">'Count'</span>]].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a><span class="cf">for</span> c <span class="kw">in</span> mlgp[[<span class="st">'Count'</span>]].columns.values:</span>
<span id="cb23-2"><a href="#cb23-2"></a>    mlgp[c] <span class="op">=</span> rs.fit_transform( (mlgp[c]<span class="op">/</span>total).values.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>) )</span>
<span id="cb23-3"><a href="#cb23-3"></a></span>
<span id="cb23-4"><a href="#cb23-4"></a>mlgp[[<span class="st">'Count'</span>]].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a>cols <span class="op">=</span> []</span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="cf">for</span> c <span class="kw">in</span> mlgp.columns.values:</span>
<span id="cb24-3"><a href="#cb24-3"></a>    l0 <span class="op">=</span> c[<span class="dv">0</span>]</span>
<span id="cb24-4"><a href="#cb24-4"></a>    l1 <span class="op">=</span> c[<span class="dv">1</span>]</span>
<span id="cb24-5"><a href="#cb24-5"></a>    l2 <span class="op">=</span> <span class="st">"Multi-host"</span> <span class="cf">if</span> c[<span class="dv">2</span>] <span class="cf">else</span> <span class="st">"Single host"</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>    </span>
<span id="cb24-7"><a href="#cb24-7"></a>    colname <span class="op">=</span> <span class="st">""</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>    </span>
<span id="cb24-9"><a href="#cb24-9"></a>    <span class="cf">if</span> l0<span class="op">==</span><span class="st">'MSOA11CD'</span>:</span>
<span id="cb24-10"><a href="#cb24-10"></a>        cols.append(l0)</span>
<span id="cb24-11"><a href="#cb24-11"></a>    <span class="cf">elif</span> l0<span class="op">==</span><span class="st">'Mean'</span>:</span>
<span id="cb24-12"><a href="#cb24-12"></a>        cols.append(<span class="ss">f"</span><span class="sc">{</span>l1<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>l2<span class="sc">}</span><span class="ss"> Mean"</span>)</span>
<span id="cb24-13"><a href="#cb24-13"></a>    <span class="cf">elif</span> l0<span class="op">==</span><span class="st">'Count'</span>:</span>
<span id="cb24-14"><a href="#cb24-14"></a>        cols.append(<span class="ss">f"</span><span class="sc">{</span>l1<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>l2<span class="sc">}</span><span class="ss"> Listings"</span>)</span>
<span id="cb24-15"><a href="#cb24-15"></a>    <span class="cf">else</span>:</span>
<span id="cb24-16"><a href="#cb24-16"></a>        <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"Sorry, please specify how to handle this column"</span>)</span>
<span id="cb24-17"><a href="#cb24-17"></a></span>
<span id="cb24-18"><a href="#cb24-18"></a><span class="bu">print</span>(cols)</span>
<span id="cb24-19"><a href="#cb24-19"></a>mlgp.columns <span class="op">=</span> cols</span>
<span id="cb24-20"><a href="#cb24-20"></a>mlgp.set_index(<span class="st">'MSOA11CD'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb24-21"><a href="#cb24-21"></a>mlgp.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="pca" class="level2">
<h2 class="anchored" data-anchor-id="pca">PCA</h2>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA </span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a>max_components <span class="op">=</span> mlgp.shape[<span class="dv">0</span>] <span class="cf">if</span> mlgp.shape[<span class="dv">0</span>] <span class="op">&lt;</span> mlgp.shape[<span class="dv">1</span>] <span class="cf">else</span> mlgp.shape[<span class="dv">1</span>]</span>
<span id="cb25-4"><a href="#cb25-4"></a></span>
<span id="cb25-5"><a href="#cb25-5"></a>pca <span class="op">=</span> PCA(n_components<span class="op">=</span>max_components, whiten<span class="op">=</span><span class="va">True</span>) </span>
<span id="cb25-6"><a href="#cb25-6"></a></span>
<span id="cb25-7"><a href="#cb25-7"></a>pca.fit(mlgp)</span>
<span id="cb25-8"><a href="#cb25-8"></a></span>
<span id="cb25-9"><a href="#cb25-9"></a>explained_variance <span class="op">=</span> pca.explained_variance_ratio_</span>
<span id="cb25-10"><a href="#cb25-10"></a>singular_values <span class="op">=</span> pca.singular_values_</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a>x <span class="op">=</span> np.arange(<span class="dv">1</span>,<span class="bu">len</span>(explained_variance)<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb26-2"><a href="#cb26-2"></a>plt.plot(x, explained_variance)</span>
<span id="cb26-3"><a href="#cb26-3"></a>plt.ylabel(<span class="st">'Share of Variance Explained'</span>)</span>
<span id="cb26-4"><a href="#cb26-4"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(explained_variance)):</span>
<span id="cb27-2"><a href="#cb27-2"></a>    <span class="bu">print</span>(<span class="ss">f"Component </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">:&gt;2}</span><span class="ss"> accounts for </span><span class="sc">{</span>explained_variance[i]<span class="op">*</span><span class="dv">100</span><span class="sc">:&gt;2.2f}</span><span class="ss">% of variance"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a>keep_n_components <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb28-2"><a href="#cb28-2"></a></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="co"># If we weren't changing the number of components we</span></span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="co"># could re-use the pca object created above. </span></span>
<span id="cb28-5"><a href="#cb28-5"></a>pca <span class="op">=</span> PCA(n_components<span class="op">=</span>keep_n_components, whiten<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb28-6"><a href="#cb28-6"></a></span>
<span id="cb28-7"><a href="#cb28-7"></a>X_train <span class="op">=</span> pca.fit_transform(mlgp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a>mlgpca <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>mlgp.index)</span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(X_train.T)):</span>
<span id="cb29-4"><a href="#cb29-4"></a>    mlgpca[<span class="ss">f"Component </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>] <span class="op">=</span> X_train.T[i]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1"></a>mlgpca.sample(<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="clustering-data-frame" class="level2">
<h2 class="anchored" data-anchor-id="clustering-data-frame">Clustering Data Frame</h2>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a>cldf <span class="op">=</span> mlgpca.copy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1"></a>cols_to_plot <span class="op">=</span> np.random.choice(cldf.columns.values, <span class="dv">3</span>, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="bu">print</span>(<span class="st">"Plotting cols: "</span> <span class="op">+</span> <span class="st">", "</span>.join(cols_to_plot))</span>
<span id="cb32-3"><a href="#cb32-3"></a>rs <span class="op">=</span> cldf.copy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a>c_nm   <span class="op">=</span> <span class="st">'KMeans'</span> <span class="co"># Clustering name</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>k_pref <span class="op">=</span> <span class="dv">4</span> <span class="co"># Number of clusters</span></span>
<span id="cb33-3"><a href="#cb33-3"></a></span>
<span id="cb33-4"><a href="#cb33-4"></a>kmeans <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k_pref, n_init<span class="op">=</span><span class="dv">20</span>, random_state<span class="op">=</span><span class="dv">42</span>).fit(cldf) <span class="co"># The process</span></span>
<span id="cb33-5"><a href="#cb33-5"></a></span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="bu">print</span>(kmeans.labels_) <span class="co"># The results</span></span>
<span id="cb33-7"><a href="#cb33-7"></a></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="co"># Add it to the data frame</span></span>
<span id="cb33-9"><a href="#cb33-9"></a>rs[c_nm] <span class="op">=</span> pd.Series(kmeans.labels_, index<span class="op">=</span>cldf.index) </span>
<span id="cb33-10"><a href="#cb33-10"></a></span>
<span id="cb33-11"><a href="#cb33-11"></a><span class="co"># How are the clusters distributed?</span></span>
<span id="cb33-12"><a href="#cb33-12"></a>rs[c_nm].hist(bins<span class="op">=</span>k_pref)</span>
<span id="cb33-13"><a href="#cb33-13"></a></span>
<span id="cb33-14"><a href="#cb33-14"></a><span class="co"># Going to be a bit hard to read if </span></span>
<span id="cb33-15"><a href="#cb33-15"></a><span class="co"># we plot every variable against every</span></span>
<span id="cb33-16"><a href="#cb33-16"></a><span class="co"># other variables, so we'll just pick a few</span></span>
<span id="cb33-17"><a href="#cb33-17"></a>sns.<span class="bu">set</span>(style<span class="op">=</span><span class="st">"white"</span>)</span>
<span id="cb33-18"><a href="#cb33-18"></a>sns.pairplot(rs, </span>
<span id="cb33-19"><a href="#cb33-19"></a>             <span class="bu">vars</span><span class="op">=</span>cols_to_plot, </span>
<span id="cb33-20"><a href="#cb33-20"></a>             hue<span class="op">=</span>c_nm, markers<span class="op">=</span><span class="st">"."</span>, height<span class="op">=</span><span class="dv">3</span>, diag_kind<span class="op">=</span><span class="st">'kde'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1"></a>cgdf <span class="op">=</span> pd.merge(msoas, rs, on<span class="op">=</span><span class="st">'MSOA11CD'</span>)</span>
<span id="cb34-2"><a href="#cb34-2"></a></span>
<span id="cb34-3"><a href="#cb34-3"></a>fig, ax <span class="op">=</span> plt_ldn()</span>
<span id="cb34-4"><a href="#cb34-4"></a>fig.suptitle(<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss"> Results (k=</span><span class="sc">{</span>k_pref<span class="sc">}</span><span class="ss">)"</span>, fontsize<span class="op">=</span><span class="dv">20</span>, y<span class="op">=</span><span class="fl">0.92</span>)</span>
<span id="cb34-5"><a href="#cb34-5"></a>cgdf.plot(column<span class="op">=</span>c_nm, ax<span class="op">=</span>ax, linewidth<span class="op">=</span><span class="dv">0</span>, zorder<span class="op">=</span><span class="dv">0</span>, categorical<span class="op">=</span><span class="va">True</span>, legend<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb34-6"><a href="#cb34-6"></a></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="kw">del</span>(cgdf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One More Thingâ€¦</p>
<p>Thereâ€™s just one little problem: what assumption did I make when I started this k-means cluster analysis? Itâ€™s a huge one, and itâ€™s one of the reasons that k-means clustering can be problematic when used naivelyâ€¦</p>
<p>STOP. What critical assumption did we make when running this analysis? The â€˜Rightâ€™ Number of Clusters Again, thereâ€™s more than one way to skin this cat. In Geocomputation they use WCSS to pick the â€˜optimalâ€™ number of clusters. The idea is that you plot the average WCSS for each number of possible clusters in the range of interest (2â€¦n) and then look for a â€˜kneeâ€™ (i.e.&nbsp;kink) in the curve. The principle of this approach is that you look for the point where there is declining benefit from adding more clusters. The problem is that there is always some benefit to adding more clusters (the perfect clustering is k==n), so you donâ€™t always see a knee.</p>
<p>Another way to try to make the process of selecting the number of clusters a little less arbitrary is called the silhouette plot and (like WCSS) it allows us to evaluate the â€˜qualityâ€™ of the clustering outcome by examining the distance between each observation and the rest of the cluster. In this case itâ€™s based on Partitioning Around the Medoid (PAM).</p>
<p>Either way, to evaluate this in a systematic way, we want to do multiple k-means clusterings for multiple values of k and then we can look at which gives the best resultsâ€¦</p>
<p>Letâ€™s try it for a range of valuesâ€¦</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a><span class="co"># Adapted from: http://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_silhouette_analysis.html</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> silhouette_samples, silhouette_score</span>
<span id="cb35-3"><a href="#cb35-3"></a></span>
<span id="cb35-4"><a href="#cb35-4"></a>text <span class="op">=</span> []</span>
<span id="cb35-5"><a href="#cb35-5"></a></span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,<span class="dv">16</span>):</span>
<span id="cb35-7"><a href="#cb35-7"></a>    <span class="co"># Debugging</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>    <span class="bu">print</span>(<span class="st">"Cluster count: "</span> <span class="op">+</span> <span class="bu">str</span>(k))</span>
<span id="cb35-9"><a href="#cb35-9"></a>    </span>
<span id="cb35-10"><a href="#cb35-10"></a>    <span class="co">#############</span></span>
<span id="cb35-11"><a href="#cb35-11"></a>    <span class="co"># Do the clustering using the main columns</span></span>
<span id="cb35-12"><a href="#cb35-12"></a>    clusterer <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k, n_init<span class="op">=</span><span class="dv">20</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb35-13"><a href="#cb35-13"></a>    cluster_labels <span class="op">=</span> clusterer.fit_predict(cldf)</span>
<span id="cb35-14"><a href="#cb35-14"></a>    </span>
<span id="cb35-15"><a href="#cb35-15"></a>    <span class="co"># Calculate the overall silhouette score</span></span>
<span id="cb35-16"><a href="#cb35-16"></a>    silhouette_avg <span class="op">=</span> silhouette_score(cldf, cluster_labels)</span>
<span id="cb35-17"><a href="#cb35-17"></a>    text <span class="op">=</span> text <span class="op">+</span> [<span class="ss">f"For k=</span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> the average silhouette_score is: </span><span class="sc">{</span>silhouette_avg<span class="sc">:6.4f}</span><span class="ss">"</span>]</span>
<span id="cb35-18"><a href="#cb35-18"></a>    </span>
<span id="cb35-19"><a href="#cb35-19"></a>    <span class="co"># Calculate the silhouette values</span></span>
<span id="cb35-20"><a href="#cb35-20"></a>    sample_silhouette_values <span class="op">=</span> silhouette_samples(cldf, cluster_labels)</span>
<span id="cb35-21"><a href="#cb35-21"></a>    </span>
<span id="cb35-22"><a href="#cb35-22"></a>    <span class="co">#############</span></span>
<span id="cb35-23"><a href="#cb35-23"></a>    <span class="co"># Create a subplot with 1 row and 2 columns</span></span>
<span id="cb35-24"><a href="#cb35-24"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb35-25"><a href="#cb35-25"></a>    fig.set_size_inches(<span class="dv">9</span>, <span class="dv">5</span>)</span>
<span id="cb35-26"><a href="#cb35-26"></a></span>
<span id="cb35-27"><a href="#cb35-27"></a>    <span class="co"># The 1st subplot is the silhouette plot</span></span>
<span id="cb35-28"><a href="#cb35-28"></a>    <span class="co"># The silhouette coefficient can range from -1, 1</span></span>
<span id="cb35-29"><a href="#cb35-29"></a>    ax1.set_xlim([<span class="op">-</span><span class="fl">1.0</span>, <span class="fl">1.0</span>]) <span class="co"># Changed from -0.1, 1</span></span>
<span id="cb35-30"><a href="#cb35-30"></a>    </span>
<span id="cb35-31"><a href="#cb35-31"></a>    <span class="co"># The (n_clusters+1)*10 is for inserting blank space between silhouette</span></span>
<span id="cb35-32"><a href="#cb35-32"></a>    <span class="co"># plots of individual clusters, to demarcate them clearly.</span></span>
<span id="cb35-33"><a href="#cb35-33"></a>    ax1.set_ylim([<span class="dv">0</span>, cldf.shape[<span class="dv">0</span>] <span class="op">+</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> <span class="dv">10</span>])</span>
<span id="cb35-34"><a href="#cb35-34"></a>    </span>
<span id="cb35-35"><a href="#cb35-35"></a>    y_lower <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb35-36"><a href="#cb35-36"></a>    </span>
<span id="cb35-37"><a href="#cb35-37"></a>    <span class="co"># For each of the clusters...</span></span>
<span id="cb35-38"><a href="#cb35-38"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb35-39"><a href="#cb35-39"></a>        <span class="co"># Aggregate the silhouette scores for samples belonging to</span></span>
<span id="cb35-40"><a href="#cb35-40"></a>        <span class="co"># cluster i, and sort them</span></span>
<span id="cb35-41"><a href="#cb35-41"></a>        ith_cluster_silhouette_values <span class="op">=</span> <span class="op">\</span></span>
<span id="cb35-42"><a href="#cb35-42"></a>            sample_silhouette_values[cluster_labels <span class="op">==</span> i]</span>
<span id="cb35-43"><a href="#cb35-43"></a></span>
<span id="cb35-44"><a href="#cb35-44"></a>        ith_cluster_silhouette_values.sort()</span>
<span id="cb35-45"><a href="#cb35-45"></a></span>
<span id="cb35-46"><a href="#cb35-46"></a>        size_cluster_i <span class="op">=</span> ith_cluster_silhouette_values.shape[<span class="dv">0</span>]</span>
<span id="cb35-47"><a href="#cb35-47"></a>        y_upper <span class="op">=</span> y_lower <span class="op">+</span> size_cluster_i</span>
<span id="cb35-48"><a href="#cb35-48"></a>        </span>
<span id="cb35-49"><a href="#cb35-49"></a>        <span class="co"># Set the color ramp</span></span>
<span id="cb35-50"><a href="#cb35-50"></a>        <span class="co">#cmap  = cm.get_cmap("Spectral")</span></span>
<span id="cb35-51"><a href="#cb35-51"></a>        color <span class="op">=</span> plt.cm.Spectral(i<span class="op">/</span>k)</span>
<span id="cb35-52"><a href="#cb35-52"></a>        ax1.fill_betweenx(np.arange(y_lower, y_upper),</span>
<span id="cb35-53"><a href="#cb35-53"></a>                          <span class="dv">0</span>, ith_cluster_silhouette_values,</span>
<span id="cb35-54"><a href="#cb35-54"></a>                          facecolor<span class="op">=</span>color, edgecolor<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb35-55"><a href="#cb35-55"></a></span>
<span id="cb35-56"><a href="#cb35-56"></a>        <span class="co"># Label the silhouette plots with their cluster numbers at the middle</span></span>
<span id="cb35-57"><a href="#cb35-57"></a>        ax1.text(<span class="op">-</span><span class="fl">0.05</span>, y_lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> size_cluster_i, <span class="bu">str</span>(i))</span>
<span id="cb35-58"><a href="#cb35-58"></a></span>
<span id="cb35-59"><a href="#cb35-59"></a>        <span class="co"># Compute the new y_lower for next plot</span></span>
<span id="cb35-60"><a href="#cb35-60"></a>        y_lower <span class="op">=</span> y_upper <span class="op">+</span> <span class="dv">10</span>  <span class="co"># 10 for the 0 samples</span></span>
<span id="cb35-61"><a href="#cb35-61"></a></span>
<span id="cb35-62"><a href="#cb35-62"></a>    ax1.set_title(<span class="st">"The silhouette plot for the clusters."</span>)</span>
<span id="cb35-63"><a href="#cb35-63"></a>    ax1.set_xlabel(<span class="st">"The silhouette coefficient values"</span>)</span>
<span id="cb35-64"><a href="#cb35-64"></a>    ax1.set_ylabel(<span class="st">"Cluster label"</span>)</span>
<span id="cb35-65"><a href="#cb35-65"></a></span>
<span id="cb35-66"><a href="#cb35-66"></a>    <span class="co"># The vertical line for average silhouette score of all the values</span></span>
<span id="cb35-67"><a href="#cb35-67"></a>    ax1.axvline(x<span class="op">=</span>silhouette_avg, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb35-68"><a href="#cb35-68"></a></span>
<span id="cb35-69"><a href="#cb35-69"></a>    ax1.set_yticks([])  <span class="co"># Clear the yaxis labels / ticks</span></span>
<span id="cb35-70"><a href="#cb35-70"></a>    ax1.set_xticks(np.arange(<span class="op">-</span><span class="fl">1.0</span>, <span class="fl">1.1</span>, <span class="fl">0.2</span>)) <span class="co"># Was: [-0.1, 0, 0.2, 0.4, 0.6, 0.8, 1]</span></span>
<span id="cb35-71"><a href="#cb35-71"></a></span>
<span id="cb35-72"><a href="#cb35-72"></a>    <span class="co"># 2nd Plot showing the actual clusters formed --</span></span>
<span id="cb35-73"><a href="#cb35-73"></a>    <span class="co"># we can only do this for the first two dimensions</span></span>
<span id="cb35-74"><a href="#cb35-74"></a>    <span class="co"># so we may not see fully what is causing the </span></span>
<span id="cb35-75"><a href="#cb35-75"></a>    <span class="co"># resulting assignment</span></span>
<span id="cb35-76"><a href="#cb35-76"></a>    colors <span class="op">=</span> plt.cm.Spectral(cluster_labels.astype(<span class="bu">float</span>) <span class="op">/</span> k)</span>
<span id="cb35-77"><a href="#cb35-77"></a>    ax2.scatter(cldf[cldf.columns[<span class="dv">0</span>]], cldf[cldf.columns[<span class="dv">1</span>]], marker<span class="op">=</span><span class="st">'.'</span>, s<span class="op">=</span><span class="dv">30</span>, lw<span class="op">=</span><span class="dv">0</span>, alpha<span class="op">=</span><span class="fl">0.7</span>,</span>
<span id="cb35-78"><a href="#cb35-78"></a>                c<span class="op">=</span>colors)</span>
<span id="cb35-79"><a href="#cb35-79"></a></span>
<span id="cb35-80"><a href="#cb35-80"></a>    <span class="co"># Labeling the clusters</span></span>
<span id="cb35-81"><a href="#cb35-81"></a>    centers <span class="op">=</span> clusterer.cluster_centers_</span>
<span id="cb35-82"><a href="#cb35-82"></a>    </span>
<span id="cb35-83"><a href="#cb35-83"></a>    <span class="co"># Draw white circles at cluster centers</span></span>
<span id="cb35-84"><a href="#cb35-84"></a>    ax2.scatter(centers[:, <span class="dv">0</span>], centers[:, <span class="dv">1</span>],</span>
<span id="cb35-85"><a href="#cb35-85"></a>                marker<span class="op">=</span><span class="st">'o'</span>, c<span class="op">=</span><span class="st">"white"</span>, alpha<span class="op">=</span><span class="dv">1</span>, s<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb35-86"><a href="#cb35-86"></a></span>
<span id="cb35-87"><a href="#cb35-87"></a>    <span class="cf">for</span> i, c <span class="kw">in</span> <span class="bu">enumerate</span>(centers):</span>
<span id="cb35-88"><a href="#cb35-88"></a>        ax2.scatter(c[<span class="dv">0</span>], c[<span class="dv">1</span>], marker<span class="op">=</span><span class="st">'$</span><span class="sc">%d</span><span class="st">$'</span> <span class="op">%</span> i, alpha<span class="op">=</span><span class="dv">1</span>, s<span class="op">=</span><span class="dv">50</span>)</span>
<span id="cb35-89"><a href="#cb35-89"></a></span>
<span id="cb35-90"><a href="#cb35-90"></a>    ax2.set_title(<span class="st">"Visualization of the clustered data"</span>)</span>
<span id="cb35-91"><a href="#cb35-91"></a>    ax2.set_xlabel(<span class="st">"Feature space for the 1st feature"</span>)</span>
<span id="cb35-92"><a href="#cb35-92"></a>    ax2.set_ylabel(<span class="st">"Feature space for the 2nd feature"</span>)</span>
<span id="cb35-93"><a href="#cb35-93"></a></span>
<span id="cb35-94"><a href="#cb35-94"></a>    plt.suptitle((<span class="st">"Silhouette analysis for KMeans clustering on sample data "</span></span>
<span id="cb35-95"><a href="#cb35-95"></a>                  <span class="st">"with n_clusters = </span><span class="sc">%d</span><span class="st">"</span> <span class="op">%</span> k),</span>
<span id="cb35-96"><a href="#cb35-96"></a>                 fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb35-97"><a href="#cb35-97"></a></span>
<span id="cb35-98"><a href="#cb35-98"></a>    plt.show()</span>
<span id="cb35-99"><a href="#cb35-99"></a></span>
<span id="cb35-100"><a href="#cb35-100"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>.join(text))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Interpreting the Results</p>
<p>STOP. Make sure that you understand how the silhouette plot and value work, and why your results may diverge from mine.</p>
<p>We can use the largest average silhouette score to determine the â€˜naturalâ€™ number of clusters in the data, but that thatâ€™s only if we donâ€™t have any kind of underlying theory, other empirical evidence, or even just a reason for choosing a different valueâ€¦ Again, weâ€™re now getting in areas where your judgement and your ability to communicate your rationale to readers is the key thing.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1"></a>c_nm   <span class="op">=</span> <span class="st">'KMeans'</span></span>
<span id="cb36-2"><a href="#cb36-2"></a>k_pref <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb36-3"><a href="#cb36-3"></a>kmeans <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k_pref, n_init<span class="op">=</span><span class="dv">75</span>, random_state<span class="op">=</span><span class="dv">42</span>).fit(cldf)</span>
<span id="cb36-4"><a href="#cb36-4"></a></span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="co"># Convert to a series</span></span>
<span id="cb36-6"><a href="#cb36-6"></a>s <span class="op">=</span> pd.Series(kmeans.labels_, index<span class="op">=</span>cldf.index, name<span class="op">=</span>c_nm)</span>
<span id="cb36-7"><a href="#cb36-7"></a></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="co"># We do this for plotting</span></span>
<span id="cb36-9"><a href="#cb36-9"></a>rs[c_nm] <span class="op">=</span> s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a>cgdf <span class="op">=</span> pd.merge(msoas, rs, on<span class="op">=</span><span class="st">'MSOA11CD'</span>)</span>
<span id="cb37-2"><a href="#cb37-2"></a></span>
<span id="cb37-3"><a href="#cb37-3"></a>fig, ax <span class="op">=</span> plt_ldn()</span>
<span id="cb37-4"><a href="#cb37-4"></a>fig.suptitle(<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss"> Results (k=</span><span class="sc">{</span>k_pref<span class="sc">}</span><span class="ss">)"</span>, fontsize<span class="op">=</span><span class="dv">20</span>, y<span class="op">=</span><span class="fl">0.92</span>)</span>
<span id="cb37-5"><a href="#cb37-5"></a>cgdf.plot(column<span class="op">=</span>c_nm, ax<span class="op">=</span>ax, linewidth<span class="op">=</span><span class="dv">0</span>, zorder<span class="op">=</span><span class="dv">0</span>, categorical<span class="op">=</span><span class="va">True</span>, legend<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb37-6"><a href="#cb37-6"></a></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="kw">del</span>(cgdf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>â€˜Representativeâ€™ Centroids To get a sense of how these clusters differ we can try to extract â€˜representativeâ€™ centroids (mid-points of the multi-dimensional cloud that constitutes a cluster). In the case of k-means this will work quite will since the clusters are explicitly built around mean centroids. Thereâ€™s also a k-medoids clustering approach built around the median centroid.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1"></a>centroids <span class="op">=</span> <span class="va">None</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">sorted</span>(rs[c_nm].unique()):</span>
<span id="cb38-3"><a href="#cb38-3"></a>    <span class="bu">print</span>(<span class="ss">f"Processing cluster </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb38-4"><a href="#cb38-4"></a></span>
<span id="cb38-5"><a href="#cb38-5"></a>    clmsoas <span class="op">=</span> rs[rs[c_nm]<span class="op">==</span>k]</span>
<span id="cb38-6"><a href="#cb38-6"></a>    <span class="cf">if</span> centroids <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb38-7"><a href="#cb38-7"></a>        centroids <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>clmsoas.columns.values)</span>
<span id="cb38-8"><a href="#cb38-8"></a>    centroids <span class="op">=</span> centroids.append(clmsoas.mean(), ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-9"><a href="#cb38-9"></a></span>
<span id="cb38-10"><a href="#cb38-10"></a>odf <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">'Variable'</span>,<span class="st">'Cluster'</span>,<span class="st">'Std. Value'</span>])</span>
<span id="cb38-11"><a href="#cb38-11"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(centroids.index)):</span>
<span id="cb38-12"><a href="#cb38-12"></a>    row <span class="op">=</span> centroids.iloc[i,:]</span>
<span id="cb38-13"><a href="#cb38-13"></a>    c_index <span class="op">=</span> <span class="bu">list</span>(centroids.columns.values).index(c_nm)</span>
<span id="cb38-14"><a href="#cb38-14"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,c_index):</span>
<span id="cb38-15"><a href="#cb38-15"></a>        d <span class="op">=</span> {<span class="st">'Variable'</span>:centroids.columns[c], <span class="st">'Cluster'</span>:row[c_index], <span class="st">'Std. Value'</span>:row[c]}</span>
<span id="cb38-16"><a href="#cb38-16"></a>        odf <span class="op">=</span> odf.append(d, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-17"><a href="#cb38-17"></a></span>
<span id="cb38-18"><a href="#cb38-18"></a>g <span class="op">=</span> sns.FacetGrid(odf, col<span class="op">=</span><span class="st">"Variable"</span>, col_wrap<span class="op">=</span><span class="dv">3</span>, height<span class="op">=</span><span class="dv">3</span>, aspect<span class="op">=</span><span class="fl">1.5</span>, margin_titles<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-19"><a href="#cb38-19"></a>g <span class="op">=</span> g.<span class="bu">map</span>(plt.plot, <span class="st">"Cluster"</span>, <span class="st">"Std. Value"</span>, marker<span class="op">=</span><span class="st">"."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>DBScan</p>
<p>Of course, as weâ€™ve said above k-means is just one way of clustering, DBScan is another. Unlike k-means, we donâ€™t need to specify the number of clusters in advance. Which sounds great, but we still need to specify other parameters (typically, these are known as hyperparameters because they are about specifying parameters that help the aglorithm to find the right solutionâ€¦ or final set of parameters!) and these can have a huge impact on our results!</p>
<p>Find a Reasonable Value for Epsilon</p>
<p>Before we an use DBSCAN itâ€™s useful to find a good value for Epsilon. We can look for the point of maximum â€˜curvatureâ€™ in a nearest neigbhours plot. Which seems to be in the vicinity of 0.55. Tips on selecting min_pts can be found here.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1"></a>neigh <span class="op">=</span> NearestNeighbors(n_neighbors<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb39-2"><a href="#cb39-2"></a>nbrs <span class="op">=</span> neigh.fit(cldf)</span>
<span id="cb39-3"><a href="#cb39-3"></a>distances, indices <span class="op">=</span> nbrs.kneighbors(cldf)</span>
<span id="cb39-4"><a href="#cb39-4"></a></span>
<span id="cb39-5"><a href="#cb39-5"></a>distances <span class="op">=</span> np.sort(distances, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb39-6"><a href="#cb39-6"></a>distances <span class="op">=</span> distances[:,<span class="dv">1</span>]</span>
<span id="cb39-7"><a href="#cb39-7"></a>plt.plot(distances)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a>c_nm <span class="op">=</span> <span class="st">'DBSCAN'</span></span>
<span id="cb40-2"><a href="#cb40-2"></a></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="co"># Make numeric display a bit neater</span></span>
<span id="cb40-4"><a href="#cb40-4"></a>pd.set_option(<span class="st">'display.float_format'</span>, <span class="kw">lambda</span> x: <span class="st">'</span><span class="sc">{:,.4f}</span><span class="st">'</span>.<span class="bu">format</span>(x))</span>
<span id="cb40-5"><a href="#cb40-5"></a></span>
<span id="cb40-6"><a href="#cb40-6"></a>el  <span class="op">=</span> []</span>
<span id="cb40-7"><a href="#cb40-7"></a></span>
<span id="cb40-8"><a href="#cb40-8"></a>max_clusters  <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb40-9"><a href="#cb40-9"></a>cluster_count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb40-10"><a href="#cb40-10"></a></span>
<span id="cb40-11"><a href="#cb40-11"></a>iters <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb40-12"><a href="#cb40-12"></a></span>
<span id="cb40-13"><a href="#cb40-13"></a><span class="cf">for</span> e <span class="kw">in</span> np.arange(<span class="fl">0.5</span>, <span class="fl">2.5</span>, <span class="fl">0.01</span>):</span>
<span id="cb40-14"><a href="#cb40-14"></a>    </span>
<span id="cb40-15"><a href="#cb40-15"></a>    <span class="cf">if</span> iters <span class="op">%</span> <span class="dv">25</span><span class="op">==</span><span class="dv">0</span>: <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>iters<span class="sc">}</span><span class="ss"> epsilons explored."</span>) </span>
<span id="cb40-16"><a href="#cb40-16"></a>    </span>
<span id="cb40-17"><a href="#cb40-17"></a>    <span class="co"># Run the clustering</span></span>
<span id="cb40-18"><a href="#cb40-18"></a>    dbs <span class="op">=</span> DBSCAN(eps<span class="op">=</span>e, min_samples<span class="op">=</span>cldf.shape[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>).fit(cldf.values)</span>
<span id="cb40-19"><a href="#cb40-19"></a>    </span>
<span id="cb40-20"><a href="#cb40-20"></a>    <span class="co"># See how we did</span></span>
<span id="cb40-21"><a href="#cb40-21"></a>    s <span class="op">=</span> pd.Series(dbs.labels_, index<span class="op">=</span>cldf.index, name<span class="op">=</span>c_nm)</span>
<span id="cb40-22"><a href="#cb40-22"></a>    </span>
<span id="cb40-23"><a href="#cb40-23"></a>    row <span class="op">=</span> [e]</span>
<span id="cb40-24"><a href="#cb40-24"></a>    data <span class="op">=</span> s.value_counts()</span>
<span id="cb40-25"><a href="#cb40-25"></a>    </span>
<span id="cb40-26"><a href="#cb40-26"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">1</span>, max_clusters<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb40-27"><a href="#cb40-27"></a>        <span class="cf">try</span>:</span>
<span id="cb40-28"><a href="#cb40-28"></a>            <span class="cf">if</span> np.isnan(data[c]):</span>
<span id="cb40-29"><a href="#cb40-29"></a>                row.append(<span class="va">None</span>)</span>
<span id="cb40-30"><a href="#cb40-30"></a>            <span class="cf">else</span>: </span>
<span id="cb40-31"><a href="#cb40-31"></a>                row.append(data[c])</span>
<span id="cb40-32"><a href="#cb40-32"></a>        <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb40-33"><a href="#cb40-33"></a>            row.append(<span class="va">None</span>)</span>
<span id="cb40-34"><a href="#cb40-34"></a>    </span>
<span id="cb40-35"><a href="#cb40-35"></a>    el.append(row)</span>
<span id="cb40-36"><a href="#cb40-36"></a>    iters<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb40-37"><a href="#cb40-37"></a></span>
<span id="cb40-38"><a href="#cb40-38"></a>edf <span class="op">=</span> pd.DataFrame(el, columns<span class="op">=</span>[<span class="st">'Epsilon'</span>]<span class="op">+</span>[<span class="st">"Cluster "</span> <span class="op">+</span> <span class="bu">str</span>(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="op">-</span><span class="dv">1</span>,max_clusters<span class="op">+</span><span class="dv">1</span>))])</span>
<span id="cb40-39"><a href="#cb40-39"></a></span>
<span id="cb40-40"><a href="#cb40-40"></a><span class="co"># Make numeric display a bit neater</span></span>
<span id="cb40-41"><a href="#cb40-41"></a>pd.set_option(<span class="st">'display.float_format'</span>, <span class="kw">lambda</span> x: <span class="st">'</span><span class="sc">{:,.2f}</span><span class="st">'</span>.<span class="bu">format</span>(x))</span>
<span id="cb40-42"><a href="#cb40-42"></a></span>
<span id="cb40-43"><a href="#cb40-43"></a><span class="bu">print</span>(<span class="st">"Done."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb41"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1"></a>odf <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">'Epsilon'</span>,<span class="st">'Cluster'</span>,<span class="st">'Count'</span>])</span>
<span id="cb41-2"><a href="#cb41-2"></a></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(edf.index)):</span>
<span id="cb41-4"><a href="#cb41-4"></a>    row <span class="op">=</span> edf.iloc[i,:]</span>
<span id="cb41-5"><a href="#cb41-5"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="bu">len</span>(edf.columns.values)):</span>
<span id="cb41-6"><a href="#cb41-6"></a>        <span class="cf">if</span> row[c] <span class="op">!=</span> <span class="va">None</span> <span class="kw">and</span> <span class="kw">not</span> np.isnan(row[c]):</span>
<span id="cb41-7"><a href="#cb41-7"></a>            d <span class="op">=</span> {<span class="st">'Epsilon'</span>:row[<span class="dv">0</span>], <span class="st">'Cluster'</span>:<span class="ss">f"Cluster </span><span class="sc">{</span>c<span class="op">-</span><span class="dv">2</span><span class="sc">}</span><span class="ss">"</span>, <span class="st">'Count'</span>:row[c]}</span>
<span id="cb41-8"><a href="#cb41-8"></a>            odf <span class="op">=</span> odf.append(d, ignore_index<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1"></a>odf[<span class="st">'Count'</span>] <span class="op">=</span> odf.Count.astype(<span class="bu">float</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb43"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1"></a>xmin <span class="op">=</span> odf[odf.Cluster<span class="op">==</span><span class="st">'Cluster 0'</span>].Epsilon.<span class="bu">min</span>()</span>
<span id="cb43-2"><a href="#cb43-2"></a>xmax <span class="op">=</span> odf[(odf.Cluster<span class="op">==</span><span class="st">'Cluster -1'</span>) <span class="op">&amp;</span> (odf.Count <span class="op">&lt;</span> cldf.shape[<span class="dv">0</span>]<span class="op">/</span><span class="dv">5</span>)].Epsilon.<span class="bu">min</span>()</span>
<span id="cb43-3"><a href="#cb43-3"></a></span>
<span id="cb43-4"><a href="#cb43-4"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>))</span>
<span id="cb43-5"><a href="#cb43-5"></a>ax.set_xlim([xmin,xmax])</span>
<span id="cb43-6"><a href="#cb43-6"></a>sns.lineplot(data<span class="op">=</span>odf, x<span class="op">=</span><span class="st">'Epsilon'</span>, y<span class="op">=</span><span class="st">'Count'</span>, hue<span class="op">=</span><span class="st">'Cluster'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1"></a>e <span class="op">=</span> <span class="fl">0.835</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>dbs <span class="op">=</span> DBSCAN(eps<span class="op">=</span>e, min_samples<span class="op">=</span>cldf.shape[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>).fit(cldf.values)</span>
<span id="cb44-3"><a href="#cb44-3"></a>s <span class="op">=</span> pd.Series(dbs.labels_, index<span class="op">=</span>cldf.index, name<span class="op">=</span>c_nm)</span>
<span id="cb44-4"><a href="#cb44-4"></a>rs[c_nm] <span class="op">=</span> s</span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="bu">print</span>(s.value_counts())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1"></a>cgdf <span class="op">=</span> pd.merge(msoas, rs, on<span class="op">=</span><span class="st">'MSOA11CD'</span>)</span>
<span id="cb45-2"><a href="#cb45-2"></a></span>
<span id="cb45-3"><a href="#cb45-3"></a>fig, ax <span class="op">=</span> plt_ldn()</span>
<span id="cb45-4"><a href="#cb45-4"></a>fig.suptitle(<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss"> Results"</span>, fontsize<span class="op">=</span><span class="dv">20</span>, y<span class="op">=</span><span class="fl">0.92</span>)</span>
<span id="cb45-5"><a href="#cb45-5"></a></span>
<span id="cb45-6"><a href="#cb45-6"></a>cgdf.plot(column<span class="op">=</span>c_nm, ax<span class="op">=</span>ax, linewidth<span class="op">=</span><span class="dv">0</span>, zorder<span class="op">=</span><span class="dv">0</span>, legend<span class="op">=</span><span class="va">True</span>, categorical<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb45-7"><a href="#cb45-7"></a></span>
<span id="cb45-8"><a href="#cb45-8"></a><span class="kw">del</span>(cgdf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb46"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1"></a><span class="im">from</span> sompy.sompy <span class="im">import</span> SOMFactory</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb47"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a>cldf.columns.values</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb48"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1"></a>c_nm <span class="op">=</span> <span class="st">'SOM'</span></span>
<span id="cb48-2"><a href="#cb48-2"></a></span>
<span id="cb48-3"><a href="#cb48-3"></a>sm <span class="op">=</span> SOMFactory().build(</span>
<span id="cb48-4"><a href="#cb48-4"></a>    cldf.values, mapsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">15</span>),</span>
<span id="cb48-5"><a href="#cb48-5"></a>    normalization<span class="op">=</span><span class="st">'var'</span>, initialization<span class="op">=</span><span class="st">'random'</span>, component_names<span class="op">=</span>cldf.columns.values)</span>
<span id="cb48-6"><a href="#cb48-6"></a>sm.train(n_job<span class="op">=</span><span class="dv">4</span>, verbose<span class="op">=</span><span class="va">False</span>, train_rough_len<span class="op">=</span><span class="dv">2</span>, train_finetune_len<span class="op">=</span><span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a>topographic_error  <span class="op">=</span> sm.calculate_topographic_error()</span>
<span id="cb49-2"><a href="#cb49-2"></a>quantization_error <span class="op">=</span> np.mean(sm._bmu[<span class="dv">1</span>])</span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="bu">print</span>(<span class="st">"Topographic error = </span><span class="sc">{0:0.5f}</span><span class="st">; Quantization error = </span><span class="sc">{1:0.5f}</span><span class="st">"</span>.<span class="bu">format</span>(topographic_error, quantization_error))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb50"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1"></a><span class="im">from</span> sompy.visualization.mapview <span class="im">import</span> View2D</span>
<span id="cb50-2"><a href="#cb50-2"></a>view2D <span class="op">=</span> View2D(<span class="dv">10</span>, <span class="dv">10</span>, <span class="st">"rand data"</span>, text_size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb50-3"><a href="#cb50-3"></a>view2D.show(sm, col_sz<span class="op">=</span><span class="dv">4</span>, which_dim<span class="op">=</span><span class="st">"all"</span>, denormalize<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb51"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1"></a><span class="im">from</span> sompy.visualization.bmuhits <span class="im">import</span> BmuHitsView</span>
<span id="cb51-2"><a href="#cb51-2"></a>vhts <span class="op">=</span> BmuHitsView(<span class="dv">15</span>, <span class="dv">15</span>, <span class="st">"Hits Map"</span>, text_size<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb51-3"><a href="#cb51-3"></a>vhts.show(sm, anotate<span class="op">=</span><span class="va">True</span>, onlyzeros<span class="op">=</span><span class="va">False</span>, labelsize<span class="op">=</span><span class="dv">9</span>, cmap<span class="op">=</span><span class="st">"plasma"</span>, logaritmic<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1"></a><span class="im">from</span> sompy.visualization.hitmap <span class="im">import</span> HitMapView</span>
<span id="cb52-2"><a href="#cb52-2"></a></span>
<span id="cb52-3"><a href="#cb52-3"></a>k_val <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb52-4"><a href="#cb52-4"></a>sm.cluster(k_val)</span>
<span id="cb52-5"><a href="#cb52-5"></a>hits  <span class="op">=</span> HitMapView(<span class="dv">15</span>, <span class="dv">15</span>, <span class="st">"Clustering"</span>, text_size<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb52-6"><a href="#cb52-6"></a>a     <span class="op">=</span> hits.show(sm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1"></a><span class="co"># Get the labels for each BMU</span></span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="co"># in the SOM (15 * 10 neurons)</span></span>
<span id="cb53-3"><a href="#cb53-3"></a>clabs <span class="op">=</span> sm.cluster_labels</span>
<span id="cb53-4"><a href="#cb53-4"></a></span>
<span id="cb53-5"><a href="#cb53-5"></a><span class="co"># Project the data on to the SOM</span></span>
<span id="cb53-6"><a href="#cb53-6"></a><span class="co"># so that we get the BMU for each</span></span>
<span id="cb53-7"><a href="#cb53-7"></a><span class="co"># of the original data points</span></span>
<span id="cb53-8"><a href="#cb53-8"></a>bmus  <span class="op">=</span> sm.project_data(cldf.values)</span>
<span id="cb53-9"><a href="#cb53-9"></a></span>
<span id="cb53-10"><a href="#cb53-10"></a><span class="co"># Turn the BMUs into cluster labels</span></span>
<span id="cb53-11"><a href="#cb53-11"></a><span class="co"># and append to the data frame</span></span>
<span id="cb53-12"><a href="#cb53-12"></a>s <span class="op">=</span> pd.Series(clabs[bmus], index<span class="op">=</span>rs.index, name<span class="op">=</span>c_nm)</span>
<span id="cb53-13"><a href="#cb53-13"></a></span>
<span id="cb53-14"><a href="#cb53-14"></a>rs[c_nm] <span class="op">=</span> s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb54"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1"></a>cgdf <span class="op">=</span> pd.merge(msoas, rs, on<span class="op">=</span><span class="st">'MSOA11CD'</span>)</span>
<span id="cb54-2"><a href="#cb54-2"></a></span>
<span id="cb54-3"><a href="#cb54-3"></a>fig, ax <span class="op">=</span> plt_ldn()</span>
<span id="cb54-4"><a href="#cb54-4"></a>fig.suptitle(<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss"> Results"</span>, fontsize<span class="op">=</span><span class="dv">20</span>, y<span class="op">=</span><span class="fl">0.92</span>)</span>
<span id="cb54-5"><a href="#cb54-5"></a></span>
<span id="cb54-6"><a href="#cb54-6"></a>cgdf.plot(column<span class="op">=</span>c_nm, ax<span class="op">=</span>ax, linewidth<span class="op">=</span><span class="dv">0</span>, zorder<span class="op">=</span><span class="dv">0</span>, legend<span class="op">=</span><span class="va">True</span>, categorical<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb54-7"><a href="#cb54-7"></a></span>
<span id="cb54-8"><a href="#cb54-8"></a><span class="kw">del</span>(cgdf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb55"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1"></a>centroids <span class="op">=</span> <span class="va">None</span></span>
<span id="cb55-2"><a href="#cb55-2"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">sorted</span>(rs[c_nm].unique()):</span>
<span id="cb55-3"><a href="#cb55-3"></a>    <span class="bu">print</span>(<span class="ss">f"Processing cluster </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb55-4"><a href="#cb55-4"></a></span>
<span id="cb55-5"><a href="#cb55-5"></a>    clsoas <span class="op">=</span> rs[rs[c_nm]<span class="op">==</span>k]</span>
<span id="cb55-6"><a href="#cb55-6"></a>    <span class="cf">if</span> centroids <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb55-7"><a href="#cb55-7"></a>        centroids <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>clsoas.columns.values)</span>
<span id="cb55-8"><a href="#cb55-8"></a>    centroids <span class="op">=</span> centroids.append(clsoas.mean(), ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-9"><a href="#cb55-9"></a></span>
<span id="cb55-10"><a href="#cb55-10"></a>odf <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">'Variable'</span>,<span class="st">'Cluster'</span>,<span class="st">'Std. Value'</span>])</span>
<span id="cb55-11"><a href="#cb55-11"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(centroids.index)):</span>
<span id="cb55-12"><a href="#cb55-12"></a>    row <span class="op">=</span> centroids.iloc[i,:]</span>
<span id="cb55-13"><a href="#cb55-13"></a>    c_index <span class="op">=</span> <span class="bu">list</span>(centroids.columns.values).index(c_nm)</span>
<span id="cb55-14"><a href="#cb55-14"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,c_index):</span>
<span id="cb55-15"><a href="#cb55-15"></a>        d <span class="op">=</span> {<span class="st">'Variable'</span>:centroids.columns[c], <span class="st">'Cluster'</span>:row[c_index], <span class="st">'Std. Value'</span>:row[c]}</span>
<span id="cb55-16"><a href="#cb55-16"></a>        odf <span class="op">=</span> odf.append(d, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-17"><a href="#cb55-17"></a></span>
<span id="cb55-18"><a href="#cb55-18"></a>g <span class="op">=</span> sns.FacetGrid(odf, col<span class="op">=</span><span class="st">"Variable"</span>, col_wrap<span class="op">=</span><span class="dv">3</span>, height<span class="op">=</span><span class="dv">3</span>, aspect<span class="op">=</span><span class="fl">1.5</span>, margin_titles<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-19"><a href="#cb55-19"></a>g <span class="op">=</span> g.<span class="bu">map</span>(plt.plot, <span class="st">"Cluster"</span>, <span class="st">"Std. Value"</span>, marker<span class="op">=</span><span class="st">"."</span>)</span>
<span id="cb55-20"><a href="#cb55-20"></a></span>
<span id="cb55-21"><a href="#cb55-21"></a><span class="kw">del</span>(odf, centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="which-clustering-approach-is-right" class="level3">
<h3 class="anchored" data-anchor-id="which-clustering-approach-is-right">Which Clustering Approach is Right?</h3>
<p>The reason that there is no â€˜rightâ€™ approach to clustering is that it all depends on what youâ€™re trying to accomplish and how youâ€™re <em>reasoning</em> about your problem. The image below highlights the extent to which the different clustering approaches in sklearn can produce different results â€“ and this is only for the <em>non-geographic</em> algorithms!</p>
<p><a href="http://scikit-learn.org/stable/modules/clustering.html#clustering"><img alt="Clustering algorithm comparison" src="http://scikit-learn.org/stable/_images/sphx_glr_plot_cluster_comparison_0011.png" width="700px"></a></p>
<p><em>Note:</em> for geographically-aware clustering you need to look at PySAL.</p>
<p>To think about this in a little more detail:</p>
<ul>
<li>If I run an online company and I want to classify my customers on the basis of their product purchases, then I probably donâ€™t care much about where they are, only about what they buy, and so my clustering approach doesnâ€™t need to take geography into account. I might well <em>discover</em> that many of my most valuable customers live in a few areas, but that is a finding, not a factor, in my research.</li>
<li>Conversely, if I am looking for cancer clusters then I might well care a <em>lot</em> about geography because I want to make sure that I donâ€™t overlook an important cluster of cases because itâ€™s â€˜hiddenâ€™ inside an area with lots of people who donâ€™t have cancer. In that case, I want my clusters to take geography into account. That approach might classify an area with a smaller proportion of cancer patients as part of a â€˜cancer clusterâ€™ but thatâ€™s because it is still significant <em>because</em> of the geography.</li>
</ul>
<p>So you can undertake a spatial analysis using <em>either</em> approach, it just depends on the role that you think geography should play in producing the clusters in the first place. Weâ€™ll see this in action today!</p>
<section id="ensure-plotting-output" class="level4">
<h4 class="anchored" data-anchor-id="ensure-plotting-output">Ensure Plotting Output</h4>
<div class="sourceCode" id="cb56"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb56-2"><a href="#cb56-2"></a>mpl.use(<span class="st">'TkAgg'</span>)</span>
<span id="cb56-3"><a href="#cb56-3"></a><span class="op">%</span>matplotlib inline</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="importing-the-libraries" class="level4">
<h4 class="anchored" data-anchor-id="importing-the-libraries">Importing the Libraries</h4>
<div class="sourceCode" id="cb57"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb57-2"><a href="#cb57-2"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb57-3"><a href="#cb57-3"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb57-4"><a href="#cb57-4"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb57-5"><a href="#cb57-5"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb57-6"><a href="#cb57-6"></a><span class="im">import</span> matplotlib.cm <span class="im">as</span> cm</span>
<span id="cb57-7"><a href="#cb57-7"></a><span class="im">import</span> requests</span>
<span id="cb57-8"><a href="#cb57-8"></a><span class="im">import</span> zipfile</span>
<span id="cb57-9"><a href="#cb57-9"></a><span class="im">import</span> re</span>
<span id="cb57-10"><a href="#cb57-10"></a><span class="im">import</span> os</span>
<span id="cb57-11"><a href="#cb57-11"></a><span class="im">import</span> pickle <span class="im">as</span> pk</span>
<span id="cb57-12"><a href="#cb57-12"></a></span>
<span id="cb57-13"><a href="#cb57-13"></a><span class="im">from</span> io <span class="im">import</span> BytesIO, StringIO</span>
<span id="cb57-14"><a href="#cb57-14"></a><span class="im">from</span> os.path <span class="im">import</span> join <span class="im">as</span> pj</span>
<span id="cb57-15"><a href="#cb57-15"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb57-16"><a href="#cb57-16"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb57-17"><a href="#cb57-17"></a><span class="im">from</span> matplotlib.colors <span class="im">import</span> ListedColormap</span>
<span id="cb57-18"><a href="#cb57-18"></a></span>
<span id="cb57-19"><a href="#cb57-19"></a><span class="im">import</span> sklearn</span>
<span id="cb57-20"><a href="#cb57-20"></a>sklv <span class="op">=</span> <span class="bu">int</span>(sklearn.__version__.replace(<span class="st">"."</span>,<span class="st">""</span>))</span>
<span id="cb57-21"><a href="#cb57-21"></a><span class="cf">if</span> sklv <span class="op">&lt;</span> <span class="dv">210</span>:</span>
<span id="cb57-22"><a href="#cb57-22"></a>    <span class="bu">print</span>(<span class="st">"SciKit-Learn verion is: "</span> <span class="op">+</span> sklearn.__version__)</span>
<span id="cb57-23"><a href="#cb57-23"></a>    <span class="bu">print</span>(<span class="st">"The OPTICS part of this notebook relies on a version &gt;= 0.21.0"</span>)</span>
<span id="cb57-24"><a href="#cb57-24"></a></span>
<span id="cb57-25"><a href="#cb57-25"></a><span class="im">from</span> sklearn.neighbors <span class="im">import</span> NearestNeighbors</span>
<span id="cb57-26"><a href="#cb57-26"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> TSNE</span>
<span id="cb57-27"><a href="#cb57-27"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb57-28"><a href="#cb57-28"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> PowerTransformer</span>
<span id="cb57-29"><a href="#cb57-29"></a><span class="im">from</span> sklearn <span class="im">import</span> preprocessing</span>
<span id="cb57-30"><a href="#cb57-30"></a><span class="im">from</span> sklearn <span class="im">import</span> cluster</span>
<span id="cb57-31"><a href="#cb57-31"></a></span>
<span id="cb57-32"><a href="#cb57-32"></a><span class="im">import</span> random</span>
<span id="cb57-33"><a href="#cb57-33"></a>random.seed(<span class="dv">42</span>)    <span class="co"># For reproducibility</span></span>
<span id="cb57-34"><a href="#cb57-34"></a>np.random.seed(<span class="dv">42</span>) <span class="co"># For reproducibility</span></span>
<span id="cb57-35"><a href="#cb57-35"></a></span>
<span id="cb57-36"><a href="#cb57-36"></a><span class="co"># Make numeric display a bit neater</span></span>
<span id="cb57-37"><a href="#cb57-37"></a>pd.set_option(<span class="st">'display.float_format'</span>, <span class="kw">lambda</span> x: <span class="st">'</span><span class="sc">{:,.2f}</span><span class="st">'</span>.<span class="bu">format</span>(x))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1"></a>src <span class="op">=</span> <span class="st">'https://github.com/kingsgeocomp/applied_gsa/blob/master/data/Census.zip?raw=true'</span></span>
<span id="cb58-2"><a href="#cb58-2"></a>dst <span class="op">=</span> os.path.join(<span class="st">'analysis'</span>,<span class="st">'Census.zip'</span>)</span>
<span id="cb58-3"><a href="#cb58-3"></a></span>
<span id="cb58-4"><a href="#cb58-4"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(dst):</span>
<span id="cb58-5"><a href="#cb58-5"></a>    <span class="cf">if</span> <span class="kw">not</span> os.path.exists(os.path.dirname(dst)):</span>
<span id="cb58-6"><a href="#cb58-6"></a>        os.makedirs(os.path.dirname(dst))</span>
<span id="cb58-7"><a href="#cb58-7"></a>    </span>
<span id="cb58-8"><a href="#cb58-8"></a>    <span class="bu">print</span>(<span class="st">"Downloading..."</span>)</span>
<span id="cb58-9"><a href="#cb58-9"></a>    r <span class="op">=</span> requests.get(src, stream<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb58-10"><a href="#cb58-10"></a>    </span>
<span id="cb58-11"><a href="#cb58-11"></a>    <span class="cf">with</span> <span class="bu">open</span>(dst, <span class="st">'wb'</span>) <span class="im">as</span> fd:</span>
<span id="cb58-12"><a href="#cb58-12"></a>        <span class="cf">for</span> chunk <span class="kw">in</span> r.iter_content(chunk_size<span class="op">=</span><span class="dv">128</span>):</span>
<span id="cb58-13"><a href="#cb58-13"></a>            fd.write(chunk)</span>
<span id="cb58-14"><a href="#cb58-14"></a><span class="cf">else</span>:</span>
<span id="cb58-15"><a href="#cb58-15"></a>    <span class="bu">print</span>(<span class="st">"File already downloaded."</span>)</span>
<span id="cb58-16"><a href="#cb58-16"></a>    </span>
<span id="cb58-17"><a href="#cb58-17"></a><span class="bu">print</span>(<span class="st">"Done."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="loading-the-nomisweb-data" class="level3">
<h3 class="anchored" data-anchor-id="loading-the-nomisweb-data">Loading the NomisWeb Data</h3>
<p>You may need to make a few adjustments to the path to get the data loaded on your own computer. But notice what weâ€™re now able to do here: using the <code>zipfile</code> library we can extract a data file (or any other file) from the Zip archive without even having to open it. Saves even more time <em>and</em> disk space!</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1"></a>z <span class="op">=</span> zipfile.ZipFile(os.path.join(<span class="st">'analysis'</span>,<span class="st">'Census.zip'</span>))</span>
<span id="cb59-2"><a href="#cb59-2"></a>z.namelist()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Weâ€™re going to save each data set to a separate data frame to make it easier to work with during cleaning. But note that this code is fairly flexible since we stick each new dataframe in a dictionary (<code>d</code>) where we can retrieve them via an iterator.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1"></a>raw   <span class="op">=</span> {}</span>
<span id="cb60-2"><a href="#cb60-2"></a>clean <span class="op">=</span> {}</span>
<span id="cb60-3"><a href="#cb60-3"></a>total_cols <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb60-4"><a href="#cb60-4"></a></span>
<span id="cb60-5"><a href="#cb60-5"></a><span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(z.namelist())):</span>
<span id="cb60-6"><a href="#cb60-6"></a>    </span>
<span id="cb60-7"><a href="#cb60-7"></a>    m  <span class="op">=</span> re.search(<span class="st">"(?:-)([^\.]+)"</span>, z.namelist()[r])</span>
<span id="cb60-8"><a href="#cb60-8"></a>    nm <span class="op">=</span> m.group(<span class="dv">1</span>)</span>
<span id="cb60-9"><a href="#cb60-9"></a>    </span>
<span id="cb60-10"><a href="#cb60-10"></a>    <span class="bu">print</span>(<span class="st">"Processing </span><span class="sc">{0}</span><span class="st"> file: "</span>.<span class="bu">format</span>(nm))</span>
<span id="cb60-11"><a href="#cb60-11"></a>    </span>
<span id="cb60-12"><a href="#cb60-12"></a>    <span class="cf">with</span> z.<span class="bu">open</span>(z.namelist()[r]) <span class="im">as</span> f:</span>
<span id="cb60-13"><a href="#cb60-13"></a>                </span>
<span id="cb60-14"><a href="#cb60-14"></a>        <span class="cf">if</span> z.namelist()[r] <span class="op">==</span> <span class="st">'99521530-Activity.csv'</span>: </span>
<span id="cb60-15"><a href="#cb60-15"></a>            raw[nm] <span class="op">=</span> pd.read_csv(BytesIO(f.read()), header<span class="op">=</span><span class="dv">7</span>, skip_blank_lines<span class="op">=</span><span class="va">True</span>, skipfooter<span class="op">=</span><span class="dv">7</span>, engine<span class="op">=</span><span class="st">'python'</span>)</span>
<span id="cb60-16"><a href="#cb60-16"></a>        <span class="cf">else</span>:</span>
<span id="cb60-17"><a href="#cb60-17"></a>            raw[nm] <span class="op">=</span> pd.read_csv(BytesIO(f.read()), header<span class="op">=</span><span class="dv">6</span>, skip_blank_lines<span class="op">=</span><span class="va">True</span>, skipfooter<span class="op">=</span><span class="dv">7</span>, engine<span class="op">=</span><span class="st">'python'</span>)</span>
<span id="cb60-18"><a href="#cb60-18"></a>    </span>
<span id="cb60-19"><a href="#cb60-19"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\t</span><span class="st">Shape of dataframe is </span><span class="sc">{0}</span><span class="st"> rows by </span><span class="sc">{1}</span><span class="st"> columns"</span>.<span class="bu">format</span>(raw[nm].shape[<span class="dv">0</span>], raw[nm].shape[<span class="dv">1</span>]))</span>
<span id="cb60-20"><a href="#cb60-20"></a>    total_cols <span class="op">+=</span> raw[nm].shape[<span class="dv">1</span>]</span>
<span id="cb60-21"><a href="#cb60-21"></a></span>
<span id="cb60-22"><a href="#cb60-22"></a><span class="bu">print</span>(<span class="st">"There are </span><span class="sc">{0}</span><span class="st"> columns in all."</span>.<span class="bu">format</span>(total_cols))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a>nm  <span class="op">=</span> <span class="st">'Occupation'</span></span>
<span id="cb61-2"><a href="#cb61-2"></a>url <span class="op">=</span> <span class="st">'https://github.com/jreades/urb-studies-predicting-gentrification/raw/master/data/src/2011/ks610ew.csv.gz'</span></span>
<span id="cb61-3"><a href="#cb61-3"></a></span>
<span id="cb61-4"><a href="#cb61-4"></a><span class="bu">print</span>(<span class="ss">f"Processing </span><span class="sc">{</span>nm<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb61-5"><a href="#cb61-5"></a>df <span class="op">=</span> pd.read_csv(url, header<span class="op">=</span><span class="dv">7</span>, skip_blank_lines<span class="op">=</span><span class="va">True</span>, compression<span class="op">=</span><span class="st">'gzip'</span>, low_memory<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb61-6"><a href="#cb61-6"></a>mapping <span class="op">=</span> {</span>
<span id="cb61-7"><a href="#cb61-7"></a>    <span class="st">'1. Managers, directors and senior officials'</span>:<span class="st">'Managers'</span>,</span>
<span id="cb61-8"><a href="#cb61-8"></a>    <span class="st">'2. Professional occupations'</span>:<span class="st">'Professionals'</span>,</span>
<span id="cb61-9"><a href="#cb61-9"></a>    <span class="st">'3. Associate professional and technical occupations'</span>:<span class="st">'Associates'</span>,</span>
<span id="cb61-10"><a href="#cb61-10"></a>    <span class="st">'4. Administrative and secretarial occupations'</span>:<span class="st">'Administrative'</span>,</span>
<span id="cb61-11"><a href="#cb61-11"></a>    <span class="st">'5. Skilled trades occupations'</span>:<span class="st">'Skilled trades'</span>,</span>
<span id="cb61-12"><a href="#cb61-12"></a>    <span class="st">'6. Caring, leisure and other service occupations'</span>:<span class="st">'Caring and Leisure'</span>,</span>
<span id="cb61-13"><a href="#cb61-13"></a>    <span class="st">'7. Sales and customer service occupations'</span>:<span class="st">'Customer Service'</span>,</span>
<span id="cb61-14"><a href="#cb61-14"></a>    <span class="st">'8. Process plant and machine operatives'</span>:<span class="st">'Operatives'</span>,</span>
<span id="cb61-15"><a href="#cb61-15"></a>    <span class="st">'9. Elementary occupations'</span>:<span class="st">'Elementary'</span></span>
<span id="cb61-16"><a href="#cb61-16"></a>}</span>
<span id="cb61-17"><a href="#cb61-17"></a>df.rename(columns<span class="op">=</span>mapping, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb61-18"><a href="#cb61-18"></a>df.drop([<span class="st">'2011 super output area - lower layer'</span>,<span class="st">'All categories: Occupation'</span>], axis<span class="op">=</span><span class="dv">1</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb61-19"><a href="#cb61-19"></a></span>
<span id="cb61-20"><a href="#cb61-20"></a>raw[nm] <span class="op">=</span> df</span>
<span id="cb61-21"><a href="#cb61-21"></a>df.sample(<span class="dv">3</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb62"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1"></a>nm  <span class="op">=</span> <span class="st">'Income'</span></span>
<span id="cb62-2"><a href="#cb62-2"></a>url  <span class="op">=</span> <span class="st">'https://data.london.gov.uk/download/household-income-estimates-small-areas/7c1099d9-327b-4f20-abb8-8c24a3c10c47/modelled-household-income-estimates-lsoa.csv'</span></span>
<span id="cb62-3"><a href="#cb62-3"></a></span>
<span id="cb62-4"><a href="#cb62-4"></a><span class="bu">print</span>(<span class="ss">f"Processing </span><span class="sc">{</span>nm<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb62-5"><a href="#cb62-5"></a>df <span class="op">=</span> pd.read_csv(url, encoding<span class="op">=</span><span class="st">'latin-1'</span>)[[<span class="st">'Code'</span>,<span class="st">'Median 2011/12'</span>]]</span>
<span id="cb62-6"><a href="#cb62-6"></a>df[<span class="st">'Median Income'</span>] <span class="op">=</span> df[<span class="st">'Median 2011/12'</span>].<span class="bu">str</span>.replace(<span class="st">'Â£'</span>,<span class="st">''</span>).<span class="bu">str</span>.replace(<span class="st">','</span>,<span class="st">''</span>).astype(<span class="st">'float'</span>)</span>
<span id="cb62-7"><a href="#cb62-7"></a>df.drop(<span class="st">'Median 2011/12'</span>, axis<span class="op">=</span><span class="dv">1</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb62-8"><a href="#cb62-8"></a></span>
<span id="cb62-9"><a href="#cb62-9"></a>raw[nm] <span class="op">=</span> df</span>
<span id="cb62-10"><a href="#cb62-10"></a>df.sample(<span class="dv">3</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb63"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1"></a>nm  <span class="op">=</span> <span class="st">'Housing'</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>url <span class="op">=</span> <span class="st">'https://data.london.gov.uk/download/average-house-prices/9a92fbaf-c04e-498a-9f8c-6c85f280817e/land-registry-house-prices-LSOA.csv'</span></span>
<span id="cb63-3"><a href="#cb63-3"></a></span>
<span id="cb63-4"><a href="#cb63-4"></a><span class="bu">print</span>(<span class="ss">f"Processing </span><span class="sc">{</span>nm<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb63-5"><a href="#cb63-5"></a>df <span class="op">=</span> pd.read_csv(url, encoding<span class="op">=</span><span class="st">'latin-1'</span>, low_memory<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb63-6"><a href="#cb63-6"></a></span>
<span id="cb63-7"><a href="#cb63-7"></a>df[<span class="st">'Borough'</span>] <span class="op">=</span> df.Area.<span class="bu">str</span>.replace(<span class="st">' [0-9A-Z]</span><span class="sc">{4}</span><span class="st">$'</span>,<span class="st">''</span>)</span>
<span id="cb63-8"><a href="#cb63-8"></a>df.drop(<span class="st">'Area'</span>, axis<span class="op">=</span><span class="dv">1</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb63-9"><a href="#cb63-9"></a></span>
<span id="cb63-10"><a href="#cb63-10"></a>df <span class="op">=</span> df[ (df.Year<span class="op">==</span><span class="st">'Year ending Dec 2011'</span>) <span class="op">&amp;</span> (df.Measure<span class="op">==</span><span class="st">'Median'</span>) ][[<span class="st">'Code'</span>,<span class="st">'Value'</span>,<span class="st">'Borough'</span>]]</span>
<span id="cb63-11"><a href="#cb63-11"></a></span>
<span id="cb63-12"><a href="#cb63-12"></a><span class="co"># Note: not all have a value for this year!</span></span>
<span id="cb63-13"><a href="#cb63-13"></a>df[<span class="st">'Median House Price'</span>] <span class="op">=</span> df.Value.<span class="bu">str</span>.replace(<span class="st">':'</span>,<span class="st">'-1'</span>).astype(<span class="bu">float</span>)</span>
<span id="cb63-14"><a href="#cb63-14"></a></span>
<span id="cb63-15"><a href="#cb63-15"></a>la <span class="op">=</span> df.groupby(<span class="st">'Borough'</span>)</span>
<span id="cb63-16"><a href="#cb63-16"></a>la_prices <span class="op">=</span> pd.DataFrame(la[<span class="st">'Median House Price'</span>].median())</span>
<span id="cb63-17"><a href="#cb63-17"></a></span>
<span id="cb63-18"><a href="#cb63-18"></a>df <span class="op">=</span> df.join(la_prices, how<span class="op">=</span><span class="st">'inner'</span>, on<span class="op">=</span><span class="st">'Borough'</span>, rsuffix<span class="op">=</span><span class="st">'_la'</span>)</span>
<span id="cb63-19"><a href="#cb63-19"></a></span>
<span id="cb63-20"><a href="#cb63-20"></a>df.loc[df[<span class="st">'Median House Price'</span>] <span class="op">&lt;</span> <span class="dv">50000</span>,<span class="st">'Median House Price'</span>] <span class="op">=</span>  df[df[<span class="st">'Median House Price'</span>] <span class="op">&lt;</span> <span class="dv">50000</span>][<span class="st">'Median House Price_la'</span>]</span>
<span id="cb63-21"><a href="#cb63-21"></a>df.drop([<span class="st">'Value'</span>,<span class="st">'Borough'</span>,<span class="st">'Median House Price_la'</span>], inplace<span class="op">=</span><span class="va">True</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb63-22"><a href="#cb63-22"></a></span>
<span id="cb63-23"><a href="#cb63-23"></a>raw[nm] <span class="op">=</span> df</span>
<span id="cb63-24"><a href="#cb63-24"></a>df.sample(<span class="dv">3</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="ons-boundary-data" class="level3">
<h3 class="anchored" data-anchor-id="ons-boundary-data">ONS Boundary Data</h3>
<p>We also need to download the LSOA boundary data. A quick Google search on â€œ2011 LSOA boundariesâ€ will lead you to the <a href="https://data.gov.uk/dataset/lower_layer_super_output_area_lsoa_boundaries">Data.gov.uk portal</a>. The rest is fairly straightforward: * We want â€˜generalisedâ€™ because that means that theyâ€™ve removed some of the detail from the boundaries so the file will load (and render) more quickly. * We want â€˜clippedâ€™ because that means that the boundaries have been clipped to the edges of the land (e.g.&nbsp;the Thames; the â€˜Fullâ€™ data set splits the Thames down the middle between adjacent LSOAs).</p>
<section id="saving-time" class="level4">
<h4 class="anchored" data-anchor-id="saving-time">Saving Time</h4>
<p>Again, in order to get you started more quickly Iâ€™ve already created a â€˜packâ€™ for you. However, note that the format of this is a GeoPackage, this is a fairly new file format designed to replace ESRIâ€™s antique Shapefile format, and it allows us to include all kinds of useful information as part of the download as well as doing away with the need to unzip a download first! So here we load the data directly into a geopandas dataframe:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1"></a>src <span class="op">=</span> <span class="st">'https://github.com/kingsgeocomp/applied_gsa/raw/master/data/London%20LSOAs.gpkg'</span></span>
<span id="cb64-2"><a href="#cb64-2"></a></span>
<span id="cb64-3"><a href="#cb64-3"></a>gdf <span class="op">=</span> gpd.read_file(src)</span>
<span id="cb64-4"><a href="#cb64-4"></a><span class="bu">print</span>(<span class="st">"Shape of LSOA file: </span><span class="sc">{0}</span><span class="st"> rows by </span><span class="sc">{1}</span><span class="st"> columns"</span>.<span class="bu">format</span>(gdf.shape[<span class="dv">0</span>], gdf.shape[<span class="dv">1</span>]))</span>
<span id="cb64-5"><a href="#cb64-5"></a>gdf.columns <span class="op">=</span> [x.lower() <span class="cf">for</span> x <span class="kw">in</span> gdf.columns.values]</span>
<span id="cb64-6"><a href="#cb64-6"></a>gdf.set_index(<span class="st">'lsoa11cd'</span>, drop<span class="op">=</span><span class="va">True</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb64-7"><a href="#cb64-7"></a>gdf.sample(<span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="error" class="level4">
<h4 class="anchored" data-anchor-id="error"><span style="color:red">Error!</span></h4>
<p>Depending on your version of GDAL/Fiona, you may not be able to read the GeoPackage file directly. In this case you will need to replace the code above with the code below for downloading and extracting a Shapefile from a Zip archive:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1"></a>src <span class="op">=</span> <span class="st">'https://github.com/kingsgeocomp/applied_gsa/blob/master/data/Lower_Layer_Super_Output_Areas_December_2011_Generalised_Clipped__Boundaries_in_England_and_Wales.zip?raw=true'</span></span>
<span id="cb65-2"><a href="#cb65-2"></a>dst <span class="op">=</span> os.path.join(<span class="st">'analysis'</span>,<span class="st">'LSOAs.zip'</span>)</span>
<span id="cb65-3"><a href="#cb65-3"></a>zpd <span class="op">=</span> <span class="st">'analysis'</span></span>
<span id="cb65-4"><a href="#cb65-4"></a></span>
<span id="cb65-5"><a href="#cb65-5"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(dst):</span>
<span id="cb65-6"><a href="#cb65-6"></a>    <span class="cf">if</span> <span class="kw">not</span> os.path.exists(os.path.dirname(dst)):</span>
<span id="cb65-7"><a href="#cb65-7"></a>        os.makedirs(os.path.dirname(dst))</span>
<span id="cb65-8"><a href="#cb65-8"></a></span>
<span id="cb65-9"><a href="#cb65-9"></a>    r <span class="op">=</span> requests.get(src, stream<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb65-10"><a href="#cb65-10"></a></span>
<span id="cb65-11"><a href="#cb65-11"></a>    <span class="cf">with</span> <span class="bu">open</span>(dst, <span class="st">'wb'</span>) <span class="im">as</span> fd:</span>
<span id="cb65-12"><a href="#cb65-12"></a>        <span class="cf">for</span> chunk <span class="kw">in</span> r.iter_content(chunk_size<span class="op">=</span><span class="dv">128</span>):</span>
<span id="cb65-13"><a href="#cb65-13"></a>            fd.write(chunk)</span>
<span id="cb65-14"><a href="#cb65-14"></a></span>
<span id="cb65-15"><a href="#cb65-15"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(zpd):</span>
<span id="cb65-16"><a href="#cb65-16"></a>    os.makedirs(os.path.dirname(zpd))</span>
<span id="cb65-17"><a href="#cb65-17"></a>    </span>
<span id="cb65-18"><a href="#cb65-18"></a>zp <span class="op">=</span> zipfile.ZipFile(dst, <span class="st">'r'</span>)</span>
<span id="cb65-19"><a href="#cb65-19"></a>zp.extractall(zpd)</span>
<span id="cb65-20"><a href="#cb65-20"></a>zp.close()</span>
<span id="cb65-21"><a href="#cb65-21"></a></span>
<span id="cb65-22"><a href="#cb65-22"></a>gdf <span class="op">=</span> gpd.read_file(os.path.join(<span class="st">'analysis'</span>,<span class="st">'lsoas'</span>,<span class="st">'Lower_Layer_Super_Output_Areas_December_2011_Generalised_Clipped__Boundaries_in_England_and_Wales.shp'</span>))</span>
<span id="cb65-23"><a href="#cb65-23"></a>gdf.crs <span class="op">=</span> {<span class="st">'init'</span> :<span class="st">'epsg:27700'</span>}</span>
<span id="cb65-24"><a href="#cb65-24"></a><span class="bu">print</span>(\<span class="st">"Shape of LSOA file: </span><span class="sc">{0}</span><span class="st"> rows by </span><span class="sc">{1}</span><span class="st"> columns</span><span class="ch">\"</span><span class="st">.format(gdf.shape[0], gdf.shape[1]))</span></span>
<span id="cb65-25"><a href="#cb65-25"></a><span class="er">gdf.set_index</span>(<span class="st">'lsoa11cd'</span>, drop<span class="op">=</span><span class="va">True</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb65-26"><a href="#cb65-26"></a>gdf.sample(<span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You can probably see why Iâ€™m a big fan of GeoPackages when theyâ€™re available!</p>
</section>
</section>
<section id="other-sources-of-data" class="level3">
<h3 class="anchored" data-anchor-id="other-sources-of-data">Other Sources of Data</h3>
<p>If youâ€™re more interested in US Census data then thereâ€™s a nice-looking (though I havenâ€™t used it) <a href="https://pypi.python.org/pypi/census">wrapper to the Census API</a>. And <a href="https://www.tandfonline.com/doi/full/10.1080/00045608.2015.1052335">Spielman and Singleton</a> have done some work on large-scale geodemographic clustering of U.S. Census geographies.</p>
</section>
<section id="direct-downloads" class="level3">
<h3 class="anchored" data-anchor-id="direct-downloads">Direct Downloads</h3>
<p>These are already clean, so we can just copy them over.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1"></a><span class="cf">for</span> t <span class="kw">in</span> [<span class="st">'Occupation'</span>,<span class="st">'Housing'</span>,<span class="st">'Income'</span>]:</span>
<span id="cb66-2"><a href="#cb66-2"></a>    raw[t].rename(columns<span class="op">=</span>{<span class="st">'Code'</span>:<span class="st">'mnemonic'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb66-3"><a href="#cb66-3"></a>    <span class="bu">print</span>(raw[t].columns)</span>
<span id="cb66-4"><a href="#cb66-4"></a>    clean[t] <span class="op">=</span> raw[t]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="dwellings" class="level3">
<h3 class="anchored" data-anchor-id="dwellings">Dwellings</h3>
<p>From dwellings weâ€™re mainly interested in the housing type since we would expect that housing typologies will be a determinant of the types of people who live in an area. We <em>could</em> look at places with no usual residents as well, or explore the distribution of shared dwellings, but this is a pretty good start.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1"></a>t <span class="op">=</span> <span class="st">'Dwellings'</span></span>
<span id="cb67-2"><a href="#cb67-2"></a>raw[t].columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb68"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1"></a><span class="co"># Select the columns we're interested in analysing</span></span>
<span id="cb68-2"><a href="#cb68-2"></a>selection <span class="op">=</span> [<span class="st">'mnemonic'</span>,</span>
<span id="cb68-3"><a href="#cb68-3"></a>    <span class="st">'Whole house or bungalow: Detached'</span>, </span>
<span id="cb68-4"><a href="#cb68-4"></a>    <span class="st">'Whole house or bungalow: Semi-detached'</span>,</span>
<span id="cb68-5"><a href="#cb68-5"></a>    <span class="st">'Whole house or bungalow: Terraced (including end-terrace)'</span>,</span>
<span id="cb68-6"><a href="#cb68-6"></a>    <span class="st">'Flat, maisonette or apartment: Purpose-built block of flats or tenement'</span>,</span>
<span id="cb68-7"><a href="#cb68-7"></a>    <span class="st">'Flat, maisonette or apartment: Part of a converted or shared house (including bed-sits)'</span>,</span>
<span id="cb68-8"><a href="#cb68-8"></a>    <span class="st">'Flat, maisonette or apartment: In a commercial building'</span></span>
<span id="cb68-9"><a href="#cb68-9"></a>]</span>
<span id="cb68-10"><a href="#cb68-10"></a></span>
<span id="cb68-11"><a href="#cb68-11"></a><span class="co"># Drop everything *not* in the selection</span></span>
<span id="cb68-12"><a href="#cb68-12"></a>clean[t] <span class="op">=</span> raw[t].drop(raw[t].columns[<span class="op">~</span>np.isin(raw[t].columns.values,selection)].values, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb68-13"><a href="#cb68-13"></a></span>
<span id="cb68-14"><a href="#cb68-14"></a>mapping <span class="op">=</span> {}</span>
<span id="cb68-15"><a href="#cb68-15"></a><span class="cf">for</span> c <span class="kw">in</span> selection[<span class="dv">1</span>:]:</span>
<span id="cb68-16"><a href="#cb68-16"></a>    m  <span class="op">=</span> re.search(<span class="st">"^(?:[^\:]*)(?:\:\s)?([^\(]+)"</span>, c)</span>
<span id="cb68-17"><a href="#cb68-17"></a>    nm <span class="op">=</span> m.group(<span class="dv">1</span>).strip()</span>
<span id="cb68-18"><a href="#cb68-18"></a>    <span class="co">#print("Renaming '{0}' to '{1}'".format(c, nm))</span></span>
<span id="cb68-19"><a href="#cb68-19"></a>    mapping[c] <span class="op">=</span> nm</span>
<span id="cb68-20"><a href="#cb68-20"></a></span>
<span id="cb68-21"><a href="#cb68-21"></a>clean[t].rename(columns<span class="op">=</span>mapping, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb68-22"><a href="#cb68-22"></a></span>
<span id="cb68-23"><a href="#cb68-23"></a>clean[t].sample(<span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="age" class="level3">
<h3 class="anchored" data-anchor-id="age">Age</h3>
<p>Clearly, some areas have more young people, some have older people, and some will be composed of families. A lot of these are going to be tied to â€˜lifestageâ€™ and so will help us to understand something about the types of areas in which they live.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1"></a>t <span class="op">=</span> <span class="st">'Age'</span></span>
<span id="cb69-2"><a href="#cb69-2"></a>raw[t].columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb70"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1"></a><span class="co"># Select the columns we're interested in analysing</span></span>
<span id="cb70-2"><a href="#cb70-2"></a>selection <span class="op">=</span> [<span class="st">'mnemonic'</span>,</span>
<span id="cb70-3"><a href="#cb70-3"></a>    <span class="st">'Age 0 to 14'</span>,</span>
<span id="cb70-4"><a href="#cb70-4"></a>    <span class="st">'Age 15 to 24'</span>,</span>
<span id="cb70-5"><a href="#cb70-5"></a>    <span class="st">'Age 25 to 44'</span>,</span>
<span id="cb70-6"><a href="#cb70-6"></a>    <span class="st">'Age 45 to 64'</span>,</span>
<span id="cb70-7"><a href="#cb70-7"></a>    <span class="st">'Age 65+'</span></span>
<span id="cb70-8"><a href="#cb70-8"></a>]</span>
<span id="cb70-9"><a href="#cb70-9"></a></span>
<span id="cb70-10"><a href="#cb70-10"></a><span class="co"># Derived columns</span></span>
<span id="cb70-11"><a href="#cb70-11"></a>raw[t][<span class="st">'Age 0 to 14'</span>]  <span class="op">=</span> raw[t][<span class="st">'Age 0 to 4'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 5 to 7'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 8 to 9'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 10 to 14'</span>] </span>
<span id="cb70-12"><a href="#cb70-12"></a>raw[t][<span class="st">'Age 15 to 24'</span>] <span class="op">=</span> raw[t][<span class="st">'Age 15'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 16 to 17'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 18 to 19'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 20 to 24'</span>]</span>
<span id="cb70-13"><a href="#cb70-13"></a>raw[t][<span class="st">'Age 25 to 44'</span>] <span class="op">=</span> raw[t][<span class="st">'Age 25 to 29'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 30 to 44'</span>]</span>
<span id="cb70-14"><a href="#cb70-14"></a>raw[t][<span class="st">'Age 45 to 64'</span>] <span class="op">=</span> raw[t][<span class="st">'Age 45 to 59'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 60 to 64'</span>]</span>
<span id="cb70-15"><a href="#cb70-15"></a>raw[t][<span class="st">'Age 65+'</span>]      <span class="op">=</span> raw[t][<span class="st">'Age 65 to 74'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 75 to 84'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 85 to 89'</span>] <span class="op">+</span> raw[t][<span class="st">'Age 90 and over'</span>]</span>
<span id="cb70-16"><a href="#cb70-16"></a></span>
<span id="cb70-17"><a href="#cb70-17"></a><span class="co"># Drop everything *not* in the selection</span></span>
<span id="cb70-18"><a href="#cb70-18"></a>clean[t] <span class="op">=</span> raw[t].drop(raw[t].columns[<span class="op">~</span>np.isin(raw[t].columns.values,selection)].values, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb70-19"><a href="#cb70-19"></a></span>
<span id="cb70-20"><a href="#cb70-20"></a>clean[t].sample(<span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="ethnicity" class="level3">
<h3 class="anchored" data-anchor-id="ethnicity">Ethnicity</h3>
<p>We might also think that the balance of ethnic groups might impact a categorisation of LSOAs in London.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1"></a>t <span class="op">=</span> <span class="st">'Ethnicity'</span></span>
<span id="cb71-2"><a href="#cb71-2"></a>raw[t].columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb72"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1"></a><span class="co"># Select the columns we're interested in analysing</span></span>
<span id="cb72-2"><a href="#cb72-2"></a>selection <span class="op">=</span> [<span class="st">'mnemonic'</span>,</span>
<span id="cb72-3"><a href="#cb72-3"></a>    <span class="st">'White'</span>, </span>
<span id="cb72-4"><a href="#cb72-4"></a>    <span class="st">'Mixed/multiple ethnic groups'</span>, </span>
<span id="cb72-5"><a href="#cb72-5"></a>    <span class="st">'Asian/Asian British'</span>, </span>
<span id="cb72-6"><a href="#cb72-6"></a>    <span class="st">'Black/African/Caribbean/Black British'</span>, </span>
<span id="cb72-7"><a href="#cb72-7"></a>    <span class="st">'Other ethnic group'</span></span>
<span id="cb72-8"><a href="#cb72-8"></a>]</span>
<span id="cb72-9"><a href="#cb72-9"></a></span>
<span id="cb72-10"><a href="#cb72-10"></a><span class="co"># Drop everything *not* in the selection</span></span>
<span id="cb72-11"><a href="#cb72-11"></a>clean[t] <span class="op">=</span> raw[t].drop(raw[t].columns[<span class="op">~</span>np.isin(raw[t].columns.values,selection)].values, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb72-12"><a href="#cb72-12"></a></span>
<span id="cb72-13"><a href="#cb72-13"></a>clean[t].sample(<span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="rooms" class="level3">
<h3 class="anchored" data-anchor-id="rooms">Rooms</h3>
<p>Letâ€™s next incorporate the amount of space available to each household.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1"></a>t <span class="op">=</span> <span class="st">'Rooms'</span></span>
<span id="cb73-2"><a href="#cb73-2"></a>raw[t].columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb74"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1"></a><span class="co"># Select the columns we're interested in analysing</span></span>
<span id="cb74-2"><a href="#cb74-2"></a>selection <span class="op">=</span> [<span class="st">'mnemonic'</span>,</span>
<span id="cb74-3"><a href="#cb74-3"></a>    <span class="st">'Occupancy rating (bedrooms) of -1 or less'</span>,</span>
<span id="cb74-4"><a href="#cb74-4"></a>    <span class="st">'Occupancy rating (rooms) of -1 or less'</span>,</span>
<span id="cb74-5"><a href="#cb74-5"></a>    <span class="st">'Average household size'</span>, </span>
<span id="cb74-6"><a href="#cb74-6"></a><span class="co">#    'Average number of bedrooms per household',</span></span>
<span id="cb74-7"><a href="#cb74-7"></a><span class="co">#    'Average number of rooms per household',</span></span>
<span id="cb74-8"><a href="#cb74-8"></a>]</span>
<span id="cb74-9"><a href="#cb74-9"></a></span>
<span id="cb74-10"><a href="#cb74-10"></a><span class="co"># Drop everything *not* in the selection</span></span>
<span id="cb74-11"><a href="#cb74-11"></a>clean[t] <span class="op">=</span> raw[t].drop(raw[t].columns[<span class="op">~</span>np.isin(raw[t].columns.values,selection)].values, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb74-12"><a href="#cb74-12"></a></span>
<span id="cb74-13"><a href="#cb74-13"></a>clean[t].sample(<span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="vehicles" class="level3">
<h3 class="anchored" data-anchor-id="vehicles">Vehicles</h3>
<p>Car ownership and use is also known to be a good predictor of social and economic â€˜statusâ€™: Guy Lansleyâ€™s article on the DLVAâ€™s registration database offers a useful perpective on the usefulness of this approach.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1"></a>t <span class="op">=</span> <span class="st">'Vehicles'</span></span>
<span id="cb75-2"><a href="#cb75-2"></a>raw[t].columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb76"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1"></a><span class="co"># Select the columns we're interested in analysing</span></span>
<span id="cb76-2"><a href="#cb76-2"></a>selection <span class="op">=</span> [<span class="st">'mnemonic'</span>,</span>
<span id="cb76-3"><a href="#cb76-3"></a>    <span class="st">'No cars or vans in household'</span>, </span>
<span id="cb76-4"><a href="#cb76-4"></a>    <span class="st">'1 car or van in household'</span>,</span>
<span id="cb76-5"><a href="#cb76-5"></a>    <span class="st">'2 cars or vans in household'</span>, </span>
<span id="cb76-6"><a href="#cb76-6"></a>    <span class="st">'3 or more cars or vans in household'</span></span>
<span id="cb76-7"><a href="#cb76-7"></a>]</span>
<span id="cb76-8"><a href="#cb76-8"></a></span>
<span id="cb76-9"><a href="#cb76-9"></a><span class="co"># Calculate a new column</span></span>
<span id="cb76-10"><a href="#cb76-10"></a>raw[t][<span class="st">'3 or more cars or vans in household'</span>] <span class="op">=</span> raw[t][<span class="st">'3 cars or vans in household'</span>] <span class="op">+</span> raw[t][<span class="st">'4 or more cars or vans in household'</span>]</span>
<span id="cb76-11"><a href="#cb76-11"></a></span>
<span id="cb76-12"><a href="#cb76-12"></a><span class="co"># Drop everything *not* in the selection</span></span>
<span id="cb76-13"><a href="#cb76-13"></a>clean[t] <span class="op">=</span> raw[t].drop(raw[t].columns[<span class="op">~</span>np.isin(raw[t].columns.values,selection)].values, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb76-14"><a href="#cb76-14"></a></span>
<span id="cb76-15"><a href="#cb76-15"></a>clean[t].sample(<span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="tenure" class="level3">
<h3 class="anchored" data-anchor-id="tenure">Tenure</h3>
<p>Ownership structure is another categorisation predictor.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1"></a>t <span class="op">=</span> <span class="st">'Tenure'</span></span>
<span id="cb77-2"><a href="#cb77-2"></a>raw[t].columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb78"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1"></a><span class="co"># Select the columns we're interested in analysing</span></span>
<span id="cb78-2"><a href="#cb78-2"></a>selection <span class="op">=</span> [<span class="st">'mnemonic'</span>,</span>
<span id="cb78-3"><a href="#cb78-3"></a>    <span class="st">'Owned'</span>, </span>
<span id="cb78-4"><a href="#cb78-4"></a>    <span class="st">'Social rented'</span>, </span>
<span id="cb78-5"><a href="#cb78-5"></a>    <span class="st">'Private rented'</span>,</span>
<span id="cb78-6"><a href="#cb78-6"></a>    <span class="st">'Shared ownership (part owned and part rented)'</span></span>
<span id="cb78-7"><a href="#cb78-7"></a>]</span>
<span id="cb78-8"><a href="#cb78-8"></a></span>
<span id="cb78-9"><a href="#cb78-9"></a><span class="co"># Drop everything *not* in the selection</span></span>
<span id="cb78-10"><a href="#cb78-10"></a>clean[t] <span class="op">=</span> raw[t].drop(raw[t].columns[<span class="op">~</span>np.isin(raw[t].columns.values,selection)].values, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb78-11"><a href="#cb78-11"></a></span>
<span id="cb78-12"><a href="#cb78-12"></a>clean[t].rename(columns<span class="op">=</span>{<span class="st">'Shared ownership (part owned and part rented)'</span>:<span class="st">'Shared ownership'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb78-13"><a href="#cb78-13"></a></span>
<span id="cb78-14"><a href="#cb78-14"></a>clean[t].sample(<span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="qualifications" class="level3">
<h3 class="anchored" data-anchor-id="qualifications">Qualifications</h3>
<p>You can find out a bit more about qualifications <a href="https://www.surreyi.gov.uk/2011-census/highest-level-of-qualification/#header-qualifications-categories">here</a>.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1"></a>t <span class="op">=</span> <span class="st">'Qualifications'</span></span>
<span id="cb79-2"><a href="#cb79-2"></a>raw[t].columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb80"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1"></a><span class="co"># Select the columns we're interested in analysing</span></span>
<span id="cb80-2"><a href="#cb80-2"></a>selection <span class="op">=</span> [<span class="st">'mnemonic'</span>,</span>
<span id="cb80-3"><a href="#cb80-3"></a>    <span class="st">'Highest level of qualification: Below Level 3 qualifications'</span>,</span>
<span id="cb80-4"><a href="#cb80-4"></a>    <span class="st">'Highest level of qualification: Level 3 and above qualifications'</span>,</span>
<span id="cb80-5"><a href="#cb80-5"></a>    <span class="st">'Highest level of qualification: Other qualifications'</span></span>
<span id="cb80-6"><a href="#cb80-6"></a>]</span>
<span id="cb80-7"><a href="#cb80-7"></a></span>
<span id="cb80-8"><a href="#cb80-8"></a><span class="co"># Derive a new aggregate field for 'didn't complete HS'</span></span>
<span id="cb80-9"><a href="#cb80-9"></a>raw[t][<span class="st">'Highest level of qualification: Below Level 3 qualifications'</span>] <span class="op">=</span> <span class="op">\</span></span>
<span id="cb80-10"><a href="#cb80-10"></a>    raw[t][<span class="st">'No qualifications'</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb80-11"><a href="#cb80-11"></a>    raw[t][<span class="st">'Highest level of qualification: Level 1 qualifications'</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb80-12"><a href="#cb80-12"></a>    raw[t][<span class="st">'Highest level of qualification: Level 2 qualifications'</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb80-13"><a href="#cb80-13"></a>    raw[t][<span class="st">'Highest level of qualification: Apprenticeship'</span>] </span>
<span id="cb80-14"><a href="#cb80-14"></a></span>
<span id="cb80-15"><a href="#cb80-15"></a>raw[t][<span class="st">'Highest level of qualification: Level 3 and above qualifications'</span>] <span class="op">=</span> <span class="op">\</span></span>
<span id="cb80-16"><a href="#cb80-16"></a>    raw[t][<span class="st">'Highest level of qualification: Level 3 qualifications'</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb80-17"><a href="#cb80-17"></a>    raw[t][<span class="st">'Highest level of qualification: Level 4 qualifications and above'</span>]</span>
<span id="cb80-18"><a href="#cb80-18"></a></span>
<span id="cb80-19"><a href="#cb80-19"></a><span class="co"># Drop everything *not* in the selection</span></span>
<span id="cb80-20"><a href="#cb80-20"></a>clean[t] <span class="op">=</span> raw[t].drop(raw[t].columns[<span class="op">~</span>np.isin(raw[t].columns.values,selection)].values, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb80-21"><a href="#cb80-21"></a></span>
<span id="cb80-22"><a href="#cb80-22"></a>mapping <span class="op">=</span> {}</span>
<span id="cb80-23"><a href="#cb80-23"></a><span class="cf">for</span> c <span class="kw">in</span> selection[<span class="dv">1</span>:]:</span>
<span id="cb80-24"><a href="#cb80-24"></a>    m  <span class="op">=</span> re.search(<span class="st">"^(?:[^\:]*)(?:\:\s)?([^\(]+)"</span>, c)</span>
<span id="cb80-25"><a href="#cb80-25"></a>    nm <span class="op">=</span> m.group(<span class="dv">1</span>).strip()</span>
<span id="cb80-26"><a href="#cb80-26"></a>    <span class="co">#print("Renaming '{0}' to '{1}'".format(c, nm))</span></span>
<span id="cb80-27"><a href="#cb80-27"></a>    mapping[c] <span class="op">=</span> nm</span>
<span id="cb80-28"><a href="#cb80-28"></a></span>
<span id="cb80-29"><a href="#cb80-29"></a>clean[t].rename(columns<span class="op">=</span>mapping, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb80-30"><a href="#cb80-30"></a></span>
<span id="cb80-31"><a href="#cb80-31"></a>clean[t].sample(<span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="activity" class="level3">
<h3 class="anchored" data-anchor-id="activity">Activity</h3>
<div class="sourceCode" id="cb81"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1"></a>t <span class="op">=</span> <span class="st">'Activity'</span></span>
<span id="cb81-2"><a href="#cb81-2"></a>raw[t].columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb82"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1"></a><span class="co"># Select the columns we're interested in analysing</span></span>
<span id="cb82-2"><a href="#cb82-2"></a>selection <span class="op">=</span> [<span class="st">'mnemonic'</span>,</span>
<span id="cb82-3"><a href="#cb82-3"></a>    <span class="st">'Economically active: In employment'</span>,</span>
<span id="cb82-4"><a href="#cb82-4"></a>    <span class="st">'Economically active: Unemployed'</span>,</span>
<span id="cb82-5"><a href="#cb82-5"></a>    <span class="st">'Economically active: Full-time student'</span>,</span>
<span id="cb82-6"><a href="#cb82-6"></a><span class="co">#    'Economically inactive: Retired',</span></span>
<span id="cb82-7"><a href="#cb82-7"></a>    <span class="st">'Economically inactive: Looking after home or family'</span>,</span>
<span id="cb82-8"><a href="#cb82-8"></a>    <span class="st">'Economically inactive: Long-term sick or disabled'</span>,</span>
<span id="cb82-9"><a href="#cb82-9"></a><span class="co">#    'Economically inactive: Other'</span></span>
<span id="cb82-10"><a href="#cb82-10"></a>]</span>
<span id="cb82-11"><a href="#cb82-11"></a></span>
<span id="cb82-12"><a href="#cb82-12"></a><span class="co"># Drop everything *not* in the selection</span></span>
<span id="cb82-13"><a href="#cb82-13"></a>clean[t] <span class="op">=</span> raw[t].drop(raw[t].columns[<span class="op">~</span>np.isin(raw[t].columns.values,selection)].values, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb82-14"><a href="#cb82-14"></a></span>
<span id="cb82-15"><a href="#cb82-15"></a>mapping <span class="op">=</span> {}</span>
<span id="cb82-16"><a href="#cb82-16"></a><span class="cf">for</span> c <span class="kw">in</span> selection[<span class="dv">1</span>:]:</span>
<span id="cb82-17"><a href="#cb82-17"></a>    m  <span class="op">=</span> re.search(<span class="st">"^(?:[^\:]*)(?:\:\s)?([^\(]+)"</span>, c)</span>
<span id="cb82-18"><a href="#cb82-18"></a>    nm <span class="op">=</span> m.group(<span class="dv">1</span>).strip()</span>
<span id="cb82-19"><a href="#cb82-19"></a>    <span class="co">#print("Renaming '{0}' to '{1}'".format(c, nm))</span></span>
<span id="cb82-20"><a href="#cb82-20"></a>    mapping[c] <span class="op">=</span> nm</span>
<span id="cb82-21"><a href="#cb82-21"></a></span>
<span id="cb82-22"><a href="#cb82-22"></a>clean[t].rename(columns<span class="op">=</span>mapping, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb82-23"><a href="#cb82-23"></a></span>
<span id="cb82-24"><a href="#cb82-24"></a>clean[t].sample(<span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="standardisation-with-sklearn" class="level3">
<h3 class="anchored" data-anchor-id="standardisation-with-sklearn">Standardisation with SKLearn</h3>
<p>Letâ€™s try standardising the data now:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1"></a><span class="co"># Here's how we can rescale and transform data easily</span></span>
<span id="cb83-2"><a href="#cb83-2"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> PowerTransformer</span>
<span id="cb83-3"><a href="#cb83-3"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> RobustScaler</span>
<span id="cb83-4"><a href="#cb83-4"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> MinMaxScaler</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb84"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1"></a>random.seed(<span class="dv">42</span>)</span>
<span id="cb84-2"><a href="#cb84-2"></a>t   <span class="op">=</span> random.sample(population<span class="op">=</span><span class="bu">list</span>(clean.keys()), k<span class="op">=</span><span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb84-3"><a href="#cb84-3"></a>col <span class="op">=</span> random.sample(population<span class="op">=</span><span class="bu">list</span>(clean[t].columns.values[<span class="dv">1</span>:]), k<span class="op">=</span><span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb84-4"><a href="#cb84-4"></a><span class="bu">print</span>(<span class="ss">f"Looking at </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> column from </span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Hereâ€™s the â€˜originalâ€™ distribution:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1"></a>plt.rcParams[<span class="st">'figure.figsize'</span>]<span class="op">=</span>(<span class="dv">7</span>,<span class="dv">3</span>)</span>
<span id="cb85-2"><a href="#cb85-2"></a>sns.distplot(clean[t][col], kde<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Hereâ€™s the version that has been re-scaled (standardised) using Min/Max rescaling:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1"></a>plt.rcParams[<span class="st">'figure.figsize'</span>]<span class="op">=</span>(<span class="dv">7</span>,<span class="dv">3</span>)</span>
<span id="cb86-2"><a href="#cb86-2"></a>sns.distplot(preprocessing.minmax_scale(clean[t][col].values.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)), kde<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Hereâ€™s a version that has been robustly rescaled:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1"></a>plt.rcParams[<span class="st">'figure.figsize'</span>]<span class="op">=</span>(<span class="dv">7</span>,<span class="dv">3</span>)</span>
<span id="cb87-2"><a href="#cb87-2"></a>sns.distplot(preprocessing.robust_scale(clean[t][col].values.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>), quantile_range<span class="op">=</span>[<span class="fl">5.0</span>, <span class="fl">95.0</span>]), kde<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>And hereâ€™s a version that has been Power Transformedâ€¦ spot the difference!</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1"></a>sns.distplot(</span>
<span id="cb88-2"><a href="#cb88-2"></a>    preprocessing.power_transform(clean[t][col].values.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>), method<span class="op">=</span><span class="st">'yeo-johnson'</span>), kde<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Combining transformation <em>and</em> rescaling:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1"></a>sns.distplot(</span>
<span id="cb89-2"><a href="#cb89-2"></a>    preprocessing.robust_scale(</span>
<span id="cb89-3"><a href="#cb89-3"></a>        preprocessing.power_transform(</span>
<span id="cb89-4"><a href="#cb89-4"></a>            clean[t][col].values.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>), method<span class="op">=</span><span class="st">'yeo-johnson'</span></span>
<span id="cb89-5"><a href="#cb89-5"></a>        ), quantile_range<span class="op">=</span>[<span class="fl">5.0</span>, <span class="fl">95.0</span>] </span>
<span id="cb89-6"><a href="#cb89-6"></a>    ), </span>
<span id="cb89-7"><a href="#cb89-7"></a>    kde<span class="op">=</span><span class="va">False</span></span>
<span id="cb89-8"><a href="#cb89-8"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb90"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1"></a><span class="co"># Set up a new dictionary for the transforms</span></span>
<span id="cb90-2"><a href="#cb90-2"></a>transformed <span class="op">=</span> {}</span>
<span id="cb90-3"><a href="#cb90-3"></a></span>
<span id="cb90-4"><a href="#cb90-4"></a>transformer <span class="op">=</span> preprocessing.PowerTransformer()</span>
<span id="cb90-5"><a href="#cb90-5"></a>scaler      <span class="op">=</span> preprocessing.RobustScaler(quantile_range<span class="op">=</span>[<span class="fl">5.0</span>, <span class="fl">95.0</span>])</span>
<span id="cb90-6"><a href="#cb90-6"></a><span class="co">#scaler      = preprocessing.MinMaxScaler()</span></span>
<span id="cb90-7"><a href="#cb90-7"></a></span>
<span id="cb90-8"><a href="#cb90-8"></a><span class="co"># Simple way to drop groups of data we don't want...</span></span>
<span id="cb90-9"><a href="#cb90-9"></a>suppress       <span class="op">=</span> <span class="bu">set</span>([<span class="st">'Rooms'</span>,<span class="st">'Vehicles'</span>])</span>
<span id="cb90-10"><a href="#cb90-10"></a></span>
<span id="cb90-11"><a href="#cb90-11"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">set</span>(clean.keys()).difference(suppress):</span>
<span id="cb90-12"><a href="#cb90-12"></a>    <span class="bu">print</span>(<span class="ss">f"Transforming </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb90-13"><a href="#cb90-13"></a>    df <span class="op">=</span> clean[k].copy(deep<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb90-14"><a href="#cb90-14"></a>    df.set_index(<span class="st">'mnemonic'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb90-15"><a href="#cb90-15"></a>    </span>
<span id="cb90-16"><a href="#cb90-16"></a>    <span class="co"># For rescale and transforming everything when the operations</span></span>
<span id="cb90-17"><a href="#cb90-17"></a>    <span class="co"># apply to each Series separately you can do it as a 1-liner like this:</span></span>
<span id="cb90-18"><a href="#cb90-18"></a>    <span class="co">#df[df.columns] = scaler.fit_transform(transformer.fit_transform(df[df.columns]))</span></span>
<span id="cb90-19"><a href="#cb90-19"></a></span>
<span id="cb90-20"><a href="#cb90-20"></a>    <span class="co"># To calculate within-*column* proportions it's like this:</span></span>
<span id="cb90-21"><a href="#cb90-21"></a>    <span class="co">#for c in df.columns.values: </span></span>
<span id="cb90-22"><a href="#cb90-22"></a>    <span class="co">#    df[c] = scaler.fit_transform( (df[c]/df[c].max() ).values.reshape(-1, 1) )</span></span>
<span id="cb90-23"><a href="#cb90-23"></a></span>
<span id="cb90-24"><a href="#cb90-24"></a>    <span class="co"># To calculate within-*group* proportions it's like this:</span></span>
<span id="cb90-25"><a href="#cb90-25"></a>    <span class="cf">if</span> k <span class="kw">in</span> [<span class="st">'Housing'</span>,<span class="st">'Income'</span>,<span class="st">'Rooms'</span>]:</span>
<span id="cb90-26"><a href="#cb90-26"></a>        df[df.columns] <span class="op">=</span> scaler.fit_transform( df[df.columns] )</span>
<span id="cb90-27"><a href="#cb90-27"></a>    <span class="cf">else</span>: </span>
<span id="cb90-28"><a href="#cb90-28"></a>        df[<span class="st">'sum'</span>] <span class="op">=</span> df[<span class="bu">list</span>(df.columns)].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb90-29"><a href="#cb90-29"></a>        <span class="cf">for</span> c <span class="kw">in</span> df.columns.values:</span>
<span id="cb90-30"><a href="#cb90-30"></a>            <span class="cf">if</span> c <span class="op">==</span> <span class="st">'sum'</span>:</span>
<span id="cb90-31"><a href="#cb90-31"></a>                df.drop([<span class="st">'sum'</span>], axis<span class="op">=</span><span class="dv">1</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb90-32"><a href="#cb90-32"></a>            <span class="cf">else</span>:</span>
<span id="cb90-33"><a href="#cb90-33"></a>                df[c] <span class="op">=</span> scaler.fit_transform( (df[c]<span class="op">/</span>df[<span class="st">'sum'</span>]).values.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) )</span>
<span id="cb90-34"><a href="#cb90-34"></a>            </span>
<span id="cb90-35"><a href="#cb90-35"></a>    <span class="co">#print(df.sample(5, random_state=42))</span></span>
<span id="cb90-36"><a href="#cb90-36"></a>    transformed[k] <span class="op">=</span> df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="creating-the-single-data-set" class="level3">
<h3 class="anchored">Creating the Single Data Set</h3>
<p>Now that weâ€™ve converted everything to percentages, itâ€™s time to bring the data together! Weâ€™ll initialise the data frame using the first matching data set, and then iterate over the rest, merging the data frames as we go.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1"></a>matching <span class="op">=</span> <span class="bu">list</span>(transformed.keys())</span>
<span id="cb91-2"><a href="#cb91-2"></a><span class="bu">print</span>(<span class="st">"Found the following data sets:</span><span class="ch">\n\t</span><span class="st">"</span> <span class="op">+</span> <span class="st">", "</span>.join(matching))</span>
<span id="cb91-3"><a href="#cb91-3"></a></span>
<span id="cb91-4"><a href="#cb91-4"></a><span class="co"># Initialise the data frame simply by grabbing the</span></span>
<span id="cb91-5"><a href="#cb91-5"></a><span class="co"># very first existing data frame and copying it </span></span>
<span id="cb91-6"><a href="#cb91-6"></a><span class="co"># directly (SCaled Data Frame == scdf)</span></span>
<span id="cb91-7"><a href="#cb91-7"></a>scdf  <span class="op">=</span> transformed[matching[<span class="dv">0</span>]].copy() </span>
<span id="cb91-8"><a href="#cb91-8"></a>lsoac <span class="op">=</span> clean[matching[<span class="dv">0</span>]].copy() </span>
<span id="cb91-9"><a href="#cb91-9"></a></span>
<span id="cb91-10"><a href="#cb91-10"></a><span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(matching)):</span>
<span id="cb91-11"><a href="#cb91-11"></a>    scdf  <span class="op">=</span> scdf.merge(transformed[matching[m]], how<span class="op">=</span><span class="st">'inner'</span>, left_on<span class="op">=</span><span class="st">'mnemonic'</span>, right_on<span class="op">=</span><span class="st">'mnemonic'</span>)</span>
<span id="cb91-12"><a href="#cb91-12"></a>    lsoac <span class="op">=</span> lsoac.merge(clean[matching[m]], how<span class="op">=</span><span class="st">'inner'</span>, left_on<span class="op">=</span><span class="st">'mnemonic'</span>, right_on<span class="op">=</span><span class="st">'mnemonic'</span>)</span>
<span id="cb91-13"><a href="#cb91-13"></a></span>
<span id="cb91-14"><a href="#cb91-14"></a>scdf.to_csv(os.path.join(<span class="st">'data'</span>,<span class="st">'Scaled_and_Transformed.csv.gz'</span>), compression<span class="op">=</span><span class="st">'gzip'</span>)</span>
<span id="cb91-15"><a href="#cb91-15"></a>lsoac.to_csv(os.path.join(<span class="st">'data'</span>,<span class="st">'Cleaned.csv.gz'</span>), compression<span class="op">=</span><span class="st">'gzip'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb92"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1"></a><span class="bu">print</span>(<span class="st">"Shape of full data frame is </span><span class="sc">{0}</span><span class="st"> by </span><span class="sc">{1}</span><span class="st">"</span>.<span class="bu">format</span>(scdf.shape[<span class="dv">0</span>], scdf.shape[<span class="dv">1</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With luck you still have 4,835 rows, but now you have rather fewer than 88 columns.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1"></a>random.seed(<span class="dv">42</span>)</span>
<span id="cb93-2"><a href="#cb93-2"></a>cols_to_plot <span class="op">=</span> random.sample(population<span class="op">=</span><span class="bu">list</span>(scdf.columns.values), k<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb93-3"><a href="#cb93-3"></a><span class="bu">print</span>(<span class="st">"Columns to plot: "</span> <span class="op">+</span> <span class="st">", "</span>.join(cols_to_plot))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb94"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1"></a><span class="co"># The data as it is now...</span></span>
<span id="cb94-2"><a href="#cb94-2"></a>sns.<span class="bu">set</span>(style<span class="op">=</span><span class="st">"whitegrid"</span>)</span>
<span id="cb94-3"><a href="#cb94-3"></a>sns.pairplot(lsoac, </span>
<span id="cb94-4"><a href="#cb94-4"></a>             <span class="bu">vars</span><span class="op">=</span>cols_to_plot, </span>
<span id="cb94-5"><a href="#cb94-5"></a>             markers<span class="op">=</span><span class="st">"."</span>, height<span class="op">=</span><span class="dv">3</span>, diag_kind<span class="op">=</span><span class="st">'kde'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb95"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1"></a><span class="co"># The data as it is now...</span></span>
<span id="cb95-2"><a href="#cb95-2"></a>sns.<span class="bu">set</span>(style<span class="op">=</span><span class="st">"whitegrid"</span>)</span>
<span id="cb95-3"><a href="#cb95-3"></a>sns.pairplot(scdf, </span>
<span id="cb95-4"><a href="#cb95-4"></a>             <span class="bu">vars</span><span class="op">=</span>cols_to_plot, </span>
<span id="cb95-5"><a href="#cb95-5"></a>             markers<span class="op">=</span><span class="st">"."</span>, height<span class="op">=</span><span class="dv">3</span>, diag_kind<span class="op">=</span><span class="st">'kde'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>STOP. Making sure that you understand how and why this results differns from the <em>same</em> plot above.</p>
<p>:::</p>
<p>Right, so you can see that rescaling the dimension hasnâ€™t <em>actually</em> changed the relationships within each dimension, or even between dimensions, but it has changed the overall range so that the the data is broadly re-centered on 0 but we <em>still</em> have the original outliers from the raw data. You could <em>also</em> do IQR standardisation (0.25 and 0.75) with the percentages, but in those cases you would have <em>more</em> outliers and then <em>more</em> extreme values skewing the results of the clustering algorithm.</p>
<section id="freeing-up-memory" class="level4">
<h4 class="anchored" data-anchor-id="freeing-up-memory">Freeing Up Memory</h4>
<p>We now have quite a few variables/datasets in memory, so itâ€™s a good idea to free up some RAM by getting rid of anything we no longer needâ€¦</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1"></a>in_scope  <span class="op">=</span> <span class="bu">set</span>([x <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">dir</span>() <span class="cf">if</span> <span class="kw">not</span> x.startswith(<span class="st">'_'</span>)])</span>
<span id="cb96-2"><a href="#cb96-2"></a>to_delete <span class="op">=</span> <span class="bu">set</span>([<span class="st">'raw'</span>,<span class="st">'clean'</span>,<span class="st">'transformed'</span>,<span class="st">'col'</span>,<span class="st">'k'</span>,<span class="st">'c'</span>,<span class="st">'lsoac'</span>,<span class="st">'scdf'</span>])</span>
<span id="cb96-3"><a href="#cb96-3"></a>z <span class="op">=</span> <span class="bu">list</span>(in_scope.intersection(to_delete))</span>
<span id="cb96-4"><a href="#cb96-4"></a><span class="kw">del</span>(z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="clustering-your-data" class="level4">
<h4 class="anchored">Clustering Your Data</h4>
<p>OK, weâ€™re finally here! Itâ€™s time to cluster the cleaned, normalised, and standardised data set! Weâ€™re going to start with the best-known clustering technique (k-means) and work from thereâ€¦ Donâ€™t take my word for it, here are the <a href="https://towardsdatascience.com/the-5-clustering-algorithms-data-scientists-need-to-know-a36d136ef68">5 Clustering Techniques Every Data Scientist Should Know</a>. This is also a good point to refer back to some of what weâ€™ve been doing (and itâ€™s a good point to potentially disagree with me!) since <a href="https://towardsdatascience.com/how-to-cluster-in-high-dimensions-4ef693bacc6">clustering in high dimensions can be problematic</a> (<em>i.e.</em> the more dimensions the worse the Euclidean distance gets as a cluster metric).</p>
<p>The effectiveness of clustering algorithms is usually demonstrated using the â€˜iris dataâ€™ â€“ itâ€™s available by default with both Seaborn and SciKit-Learn. This data doesnâ€™t usually need normalisation but itâ€™s a good way to start looking at the data across four dimensions and seeing how it varies and why some dimensions are â€˜goodâ€™ for clustering, while others are â€˜not usefulâ€™â€¦</p>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>Unfortunately, our data is a <em>lot</em> messier and has many more dimensions (&gt;25) than this.</p>
<p>:::</p>
<ul>
<li>Find the appropriate eps value: <a href="https://nbviewer.jupyter.org/github/pysal/pointpats/blob/master/notebooks/distance_statistics.ipynb#Nearest-Neighbor-Distance-Functions">Nearest Neighbour Distance Functions</a></li>
</ul>
<section id="brief-discussion" class="level4">
<h4 class="anchored" data-anchor-id="brief-discussion">Brief Discussion</h4>
<p>In the practical Iâ€™ve followed the <em>Geocomputation</em> approach of basically converting everything to a share (percentage) and then clustering on that. This is <em>one</em> way to approach this problem, but there are <em>many</em> others. For instance, many people might skip the percentages part and apply robust rescaling (<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html"><code>sklearn.preprocessing.RobustScaler</code></a>) using centering and quantile standardisation (the 5th and 95th, for example) instead. And possibly using a normalising transformation (such as a <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PowerTransformer.html">Power Transform</a>) as well.</p>
<p>I would also consider using PCA on groups of related variables (<em>e.g.</em> the housing features as a group, the ethnicity features as a group, etc.) and then take the first few eigenvalues from each group and cluster on all of those together. This would remove quite a bit of the correlation between variables and still allow us to perform hierarchical and other types of clustering on the result. It might also do a better job of preserving outliers.</p>
</section>
<section id="create-an-output-directory-and-load-the-data" class="level4">
<h4 class="anchored" data-anchor-id="create-an-output-directory-and-load-the-data">Create an Output Directory and Load the Data</h4>
<div class="sourceCode" id="cb97"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1"></a>o_dir <span class="op">=</span> os.path.join(<span class="st">'outputs'</span>,<span class="st">'clusters'</span>)</span>
<span id="cb97-2"><a href="#cb97-2"></a><span class="cf">if</span> os.path.isdir(o_dir) <span class="kw">is</span> <span class="kw">not</span> <span class="va">True</span>:</span>
<span id="cb97-3"><a href="#cb97-3"></a>    <span class="bu">print</span>(<span class="st">"Creating '</span><span class="sc">{0}</span><span class="st">' directory."</span>.<span class="bu">format</span>(o_dir))</span>
<span id="cb97-4"><a href="#cb97-4"></a>    os.makedirs(o_dir)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb98"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1"></a>df <span class="op">=</span> pd.read_csv(os.path.join(<span class="st">'data'</span>,<span class="st">'Scaled_and_Transformed.csv.gz'</span>))</span>
<span id="cb98-2"><a href="#cb98-2"></a>df.rename(columns<span class="op">=</span>{<span class="st">'mnemonic'</span>:<span class="st">'lsoacd'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb98-3"><a href="#cb98-3"></a>df.set_index(<span class="st">'lsoacd'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb98-4"><a href="#cb98-4"></a>df.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb99"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1"></a>df.sample(<span class="dv">3</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="grab-borough-boundaries-and-water-courses" class="level4">
<h4 class="anchored" data-anchor-id="grab-borough-boundaries-and-water-courses">Grab Borough Boundaries and Water Courses</h4>
<p><em>Note:</em> if reading these GeoPackages gives you errors then you will need to comment out the following two lines from the <code>plt_ldn</code> function immediately below:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1"></a>    w.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">'#79aef5'</span>, zorder<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb100-2"><a href="#cb100-2"></a>    b.plot(ax<span class="op">=</span>ax, edgecolor<span class="op">=</span><span class="st">'#cc2d2d'</span>, facecolor<span class="op">=</span><span class="st">'None'</span>, zorder<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb101"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1"></a><span class="co"># Load Water GeoPackage</span></span>
<span id="cb101-2"><a href="#cb101-2"></a>w_path <span class="op">=</span> os.path.join(<span class="st">'data'</span>,<span class="st">'Water.gpkg'</span>)</span>
<span id="cb101-3"><a href="#cb101-3"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(w_path):</span>
<span id="cb101-4"><a href="#cb101-4"></a>    water <span class="op">=</span> gpd.read_file(<span class="st">'https://github.com/kingsgeocomp/applied_gsa/raw/master/data/Water.gpkg'</span>)</span>
<span id="cb101-5"><a href="#cb101-5"></a>    water.to_file(w_path)</span>
<span id="cb101-6"><a href="#cb101-6"></a>    <span class="bu">print</span>(<span class="st">"Downloaded Water.gpkg file."</span>)</span>
<span id="cb101-7"><a href="#cb101-7"></a><span class="cf">else</span>:</span>
<span id="cb101-8"><a href="#cb101-8"></a>    water <span class="op">=</span> gpd.read_file(w_path)</span>
<span id="cb101-9"><a href="#cb101-9"></a></span>
<span id="cb101-10"><a href="#cb101-10"></a><span class="co"># Boroughs GeoPackage</span></span>
<span id="cb101-11"><a href="#cb101-11"></a>b_path <span class="op">=</span> os.path.join(<span class="st">'data'</span>,<span class="st">'Boroughs.gpkg'</span>)</span>
<span id="cb101-12"><a href="#cb101-12"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(b_path):</span>
<span id="cb101-13"><a href="#cb101-13"></a>    boroughs <span class="op">=</span> gpd.read_file(<span class="st">'https://github.com/kingsgeocomp/applied_gsa/raw/master/data/Boroughs.gpkg'</span>)</span>
<span id="cb101-14"><a href="#cb101-14"></a>    boroughs.to_file(b_path)</span>
<span id="cb101-15"><a href="#cb101-15"></a>    <span class="bu">print</span>(<span class="st">"Downloaded Boroughs.gpkg file."</span>)</span>
<span id="cb101-16"><a href="#cb101-16"></a><span class="cf">else</span>:</span>
<span id="cb101-17"><a href="#cb101-17"></a>    boroughs <span class="op">=</span> gpd.read_file(b_path)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="useful-functions-for-plotting-1" class="level4">
<h4 class="anchored" data-anchor-id="useful-functions-for-plotting-1">Useful Functions for Plotting</h4>
<div class="sourceCode" id="cb102"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1"></a><span class="kw">def</span> plt_ldn(w<span class="op">=</span>water, b<span class="op">=</span>boroughs):</span>
<span id="cb102-2"><a href="#cb102-2"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">12</span>))</span>
<span id="cb102-3"><a href="#cb102-3"></a>    w.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">'#79aef5'</span>, zorder<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb102-4"><a href="#cb102-4"></a>    b.plot(ax<span class="op">=</span>ax, edgecolor<span class="op">=</span><span class="st">'#cc2d2d'</span>, facecolor<span class="op">=</span><span class="st">'None'</span>, zorder<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb102-5"><a href="#cb102-5"></a>    ax.set_xlim([<span class="dv">502000</span>,<span class="dv">563000</span>])</span>
<span id="cb102-6"><a href="#cb102-6"></a>    ax.set_ylim([<span class="dv">155000</span>,<span class="dv">201500</span>])</span>
<span id="cb102-7"><a href="#cb102-7"></a>    ax.spines[<span class="st">'top'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb102-8"><a href="#cb102-8"></a>    ax.spines[<span class="st">'right'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb102-9"><a href="#cb102-9"></a>    ax.spines[<span class="st">'bottom'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb102-10"><a href="#cb102-10"></a>    ax.spines[<span class="st">'left'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb102-11"><a href="#cb102-11"></a>    <span class="cf">return</span> fig, ax</span>
<span id="cb102-12"><a href="#cb102-12"></a></span>
<span id="cb102-13"><a href="#cb102-13"></a><span class="kw">def</span> default_cmap(n, outliers<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb102-14"><a href="#cb102-14"></a>    cmap <span class="op">=</span> mpl.cm.get_cmap(<span class="st">'viridis_r'</span>, n)</span>
<span id="cb102-15"><a href="#cb102-15"></a>    colors <span class="op">=</span> cmap(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,n))</span>
<span id="cb102-16"><a href="#cb102-16"></a>    <span class="cf">if</span> outliers:</span>
<span id="cb102-17"><a href="#cb102-17"></a>        gray <span class="op">=</span> np.array([<span class="dv">225</span><span class="op">/</span><span class="dv">256</span>, <span class="dv">225</span><span class="op">/</span><span class="dv">256</span>, <span class="dv">225</span><span class="op">/</span><span class="dv">256</span>, <span class="dv">1</span>])</span>
<span id="cb102-18"><a href="#cb102-18"></a>        colors <span class="op">=</span> np.insert(colors, <span class="dv">0</span>, gray, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb102-19"><a href="#cb102-19"></a>    <span class="cf">return</span> ListedColormap(colors)</span>
<span id="cb102-20"><a href="#cb102-20"></a></span>
<span id="cb102-21"><a href="#cb102-21"></a><span class="co"># mappable = ax.collections[-1] if you add the geopandas</span></span>
<span id="cb102-22"><a href="#cb102-22"></a><span class="co"># plot last.</span></span>
<span id="cb102-23"><a href="#cb102-23"></a><span class="kw">def</span> add_colorbar(mappable, ax, cmap, norm, breaks, outliers<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb102-24"><a href="#cb102-24"></a>    cb <span class="op">=</span> fig.colorbar(mappable, ax<span class="op">=</span>ax, cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm,</span>
<span id="cb102-25"><a href="#cb102-25"></a>                    boundaries<span class="op">=</span>breaks,</span>
<span id="cb102-26"><a href="#cb102-26"></a>                    extend<span class="op">=</span>(<span class="st">'min'</span> <span class="cf">if</span> outliers <span class="cf">else</span> <span class="st">'neither'</span>), </span>
<span id="cb102-27"><a href="#cb102-27"></a>                    spacing<span class="op">=</span><span class="st">'uniform'</span>,</span>
<span id="cb102-28"><a href="#cb102-28"></a>                    orientation<span class="op">=</span><span class="st">'horizontal'</span>,</span>
<span id="cb102-29"><a href="#cb102-29"></a>                    fraction<span class="op">=</span><span class="fl">0.05</span>, shrink<span class="op">=</span><span class="fl">0.5</span>, pad<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb102-30"><a href="#cb102-30"></a>    cb.set_label(<span class="st">"Cluster Number"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="select-4-columns-to-plot" class="level4">
<h4 class="anchored" data-anchor-id="select-4-columns-to-plot">Select 4 Columns to Plot</h4>
<div class="sourceCode" id="cb103"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1"></a>random.seed(<span class="dv">42</span>)</span>
<span id="cb103-2"><a href="#cb103-2"></a>cols_to_plot <span class="op">=</span> random.sample(population<span class="op">=</span><span class="bu">list</span>(df.columns.values), k<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb103-3"><a href="#cb103-3"></a><span class="bu">print</span>(<span class="st">"Columns to plot: "</span> <span class="op">+</span> <span class="st">", "</span>.join(cols_to_plot))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="storing-results" class="level4">
<h4 class="anchored" data-anchor-id="storing-results">Storing Results</h4>
<div class="sourceCode" id="cb104"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1"></a>result_set <span class="op">=</span> <span class="va">None</span></span>
<span id="cb104-2"><a href="#cb104-2"></a></span>
<span id="cb104-3"><a href="#cb104-3"></a><span class="kw">def</span> add_2_rs(s, rs<span class="op">=</span>result_set):</span>
<span id="cb104-4"><a href="#cb104-4"></a>    <span class="cf">if</span> rs <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb104-5"><a href="#cb104-5"></a>        <span class="co"># Initialise</span></span>
<span id="cb104-6"><a href="#cb104-6"></a>        rs <span class="op">=</span> pd.DataFrame()</span>
<span id="cb104-7"><a href="#cb104-7"></a>    rs[s.name] <span class="op">=</span> s</span>
<span id="cb104-8"><a href="#cb104-8"></a>    <span class="cf">return</span> rs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="k-means" class="level3">
<h3 class="anchored">K-Means</h3>
<section id="importing-the-library" class="level4">
<h4 class="anchored" data-anchor-id="importing-the-library">Importing the Library</h4>
<div class="sourceCode" id="cb105"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans</span>
<span id="cb105-2"><a href="#cb105-2"></a><span class="co">#help(KMeans)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The next few code blocks may take a while to complete, largely because of the <code>pairplot</code> at the end where we ask Seaborn to plot every dimension against every other dimension <em>while</em> colouring the points according to their cluster. Iâ€™ve reduced the plotting to just three dimensions, if you want to plot all of them, then just replace the array attached to <code>vars</code> with <code>main_cols</code>, but you have to bear in mind that that is plotting 4,300 points <em>each</em> time it draws a plotâ€¦ and there are 81 of them! Itâ€™ll take a while, but it <em>will</em> do it, and try doing that in Excel or SPSS?</p>
</section>
<section id="a-first-cluster-analysis" class="level4">
<h4 class="anchored" data-anchor-id="a-first-cluster-analysis">A First Cluster Analysis</h4>
<div class="sourceCode" id="cb106"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1"></a>c_nm   <span class="op">=</span> <span class="st">'KMeans'</span> <span class="co"># Clustering name</span></span>
<span id="cb106-2"><a href="#cb106-2"></a>k_pref <span class="op">=</span> <span class="dv">6</span> <span class="co"># Number of clusters</span></span>
<span id="cb106-3"><a href="#cb106-3"></a></span>
<span id="cb106-4"><a href="#cb106-4"></a><span class="co"># Quick sanity check in case something hasn't</span></span>
<span id="cb106-5"><a href="#cb106-5"></a><span class="co"># run successfully -- these muck up k-means</span></span>
<span id="cb106-6"><a href="#cb106-6"></a>cldf <span class="op">=</span> df.drop(<span class="bu">list</span>(df.columns[df.isnull().<span class="bu">any</span>().values].values), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb106-7"><a href="#cb106-7"></a></span>
<span id="cb106-8"><a href="#cb106-8"></a>kmeans <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k_pref, n_init<span class="op">=</span><span class="dv">20</span>, random_state<span class="op">=</span><span class="dv">42</span>, n_jobs<span class="op">=-</span><span class="dv">1</span>).fit(cldf) <span class="co"># The process</span></span>
<span id="cb106-9"><a href="#cb106-9"></a></span>
<span id="cb106-10"><a href="#cb106-10"></a><span class="bu">print</span>(kmeans.labels_) <span class="co"># The results</span></span>
<span id="cb106-11"><a href="#cb106-11"></a></span>
<span id="cb106-12"><a href="#cb106-12"></a><span class="co"># Add it to the data frame</span></span>
<span id="cb106-13"><a href="#cb106-13"></a>cldf[c_nm] <span class="op">=</span> pd.Series(kmeans.labels_, index<span class="op">=</span>df.index) </span>
<span id="cb106-14"><a href="#cb106-14"></a></span>
<span id="cb106-15"><a href="#cb106-15"></a><span class="co"># How are the clusters distributed?</span></span>
<span id="cb106-16"><a href="#cb106-16"></a>cldf[c_nm].hist(bins<span class="op">=</span>k_pref)</span>
<span id="cb106-17"><a href="#cb106-17"></a></span>
<span id="cb106-18"><a href="#cb106-18"></a><span class="co"># Going to be a bit hard to read if </span></span>
<span id="cb106-19"><a href="#cb106-19"></a><span class="co"># we plot every variable against every</span></span>
<span id="cb106-20"><a href="#cb106-20"></a><span class="co"># other variables, so we'll just pick a few</span></span>
<span id="cb106-21"><a href="#cb106-21"></a>sns.<span class="bu">set</span>(style<span class="op">=</span><span class="st">"white"</span>)</span>
<span id="cb106-22"><a href="#cb106-22"></a>sns.pairplot(cldf, </span>
<span id="cb106-23"><a href="#cb106-23"></a>             <span class="bu">vars</span><span class="op">=</span>cols_to_plot, </span>
<span id="cb106-24"><a href="#cb106-24"></a>             hue<span class="op">=</span>c_nm, markers<span class="op">=</span><span class="st">"."</span>, height<span class="op">=</span><span class="dv">3</span>, diag_kind<span class="op">=</span><span class="st">'kde'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb107"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1"></a>cgdf <span class="op">=</span> gdf.join(cldf, how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb107-2"><a href="#cb107-2"></a></span>
<span id="cb107-3"><a href="#cb107-3"></a>breaks <span class="op">=</span> np.arange(<span class="dv">0</span>,cldf[c_nm].<span class="bu">max</span>()<span class="op">+</span><span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb107-4"><a href="#cb107-4"></a>cmap   <span class="op">=</span> default_cmap(<span class="bu">len</span>(breaks))</span>
<span id="cb107-5"><a href="#cb107-5"></a></span>
<span id="cb107-6"><a href="#cb107-6"></a>norm    <span class="op">=</span> mpl.colors.BoundaryNorm(breaks, cmap.N)</span>
<span id="cb107-7"><a href="#cb107-7"></a></span>
<span id="cb107-8"><a href="#cb107-8"></a>fig, ax <span class="op">=</span> plt_ldn()</span>
<span id="cb107-9"><a href="#cb107-9"></a>fig.suptitle(<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss"> Results (k=</span><span class="sc">{</span>k_pref<span class="sc">}</span><span class="ss">)"</span>, fontsize<span class="op">=</span><span class="dv">20</span>, y<span class="op">=</span><span class="fl">0.92</span>)</span>
<span id="cb107-10"><a href="#cb107-10"></a>cgdf.plot(column<span class="op">=</span>c_nm, ax<span class="op">=</span>ax, cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm, linewidth<span class="op">=</span><span class="dv">0</span>, zorder<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb107-11"><a href="#cb107-11"></a></span>
<span id="cb107-12"><a href="#cb107-12"></a>add_colorbar(ax.collections[<span class="op">-</span><span class="dv">1</span>], ax, cmap, norm, breaks)</span>
<span id="cb107-13"><a href="#cb107-13"></a></span>
<span id="cb107-14"><a href="#cb107-14"></a><span class="kw">del</span>(cgdf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="one-more-thing" class="level4">
<h4 class="anchored">One More Thingâ€¦</h4>
<p>Thereâ€™s just <em>one</em> little problem: what assumption did I make when I started this <em>k</em>-means cluster analysis? Itâ€™s a huge one, and itâ€™s one of the reasons that <em>k</em>-means clustering <em>can</em> be problematic when used naivelyâ€¦</p>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>STOP. What critical assumption did we make when running this analysis?</p>
<p>:::</p>
<section id="the-right-number-of-clusters" class="level4">
<h4 class="anchored" data-anchor-id="the-right-number-of-clusters">The â€˜Rightâ€™ Number of Clusters</h4>
<p>Again, thereâ€™s more than one way to skin this cat. In <em>Geocomputation</em> they use WCSS to pick the â€˜optimalâ€™ number of clusters. The idea is that you plot the average WCSS for each number of possible clusters in the range of interest (<code>2...n</code>) and then look for a â€˜kneeâ€™ (i.e.&nbsp;kink) in the curve. The principle of this approach is that you look for the point where there is declining benefit from adding more clusters. The problem is that there is always <em>some</em> benefit to adding more clusters (the perfect clustering is <em>k==n</em>), so you donâ€™t always see a knee.</p>
<p>Another way to try to make the process of selecting the number of clusters a little less arbitrary is called the silhouette plot and (like WCSS) it allows us to evaluate the â€˜qualityâ€™ of the clustering outcome by examining the distance between each observation and the rest of the cluster. In this case itâ€™s based on Partitioning Around the Medoid (PAM).</p>
<p>Either way, to evaluate this in a systematic way, we want to do <em>multiple</em> <em>k</em>-means clusterings for <em>multiple</em> values of <em>k</em> and then we can look at which gives the best resultsâ€¦</p>
<p>Letâ€™s try it for the range 3-9.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1"></a><span class="co"># Adapted from: http://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_silhouette_analysis.html</span></span>
<span id="cb108-2"><a href="#cb108-2"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans</span>
<span id="cb108-3"><a href="#cb108-3"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> silhouette_samples, silhouette_score</span>
<span id="cb108-4"><a href="#cb108-4"></a></span>
<span id="cb108-5"><a href="#cb108-5"></a>cldf <span class="op">=</span> df.drop(<span class="bu">list</span>(df.columns[df.isnull().<span class="bu">any</span>().values].values), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb108-6"><a href="#cb108-6"></a></span>
<span id="cb108-7"><a href="#cb108-7"></a>text <span class="op">=</span> []</span>
<span id="cb108-8"><a href="#cb108-8"></a></span>
<span id="cb108-9"><a href="#cb108-9"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>,<span class="dv">10</span>):</span>
<span id="cb108-10"><a href="#cb108-10"></a>    <span class="co"># Debugging</span></span>
<span id="cb108-11"><a href="#cb108-11"></a>    <span class="bu">print</span>(<span class="st">"Cluster count: "</span> <span class="op">+</span> <span class="bu">str</span>(k))</span>
<span id="cb108-12"><a href="#cb108-12"></a>    </span>
<span id="cb108-13"><a href="#cb108-13"></a>    <span class="co">#############</span></span>
<span id="cb108-14"><a href="#cb108-14"></a>    <span class="co"># Do the clustering using the main columns</span></span>
<span id="cb108-15"><a href="#cb108-15"></a>    clusterer <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k, n_init<span class="op">=</span><span class="dv">15</span>, random_state<span class="op">=</span><span class="dv">42</span>, n_jobs<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb108-16"><a href="#cb108-16"></a>    cluster_labels <span class="op">=</span> clusterer.fit_predict(cldf)</span>
<span id="cb108-17"><a href="#cb108-17"></a>    </span>
<span id="cb108-18"><a href="#cb108-18"></a>    <span class="co"># Calculate the overall silhouette score</span></span>
<span id="cb108-19"><a href="#cb108-19"></a>    silhouette_avg <span class="op">=</span> silhouette_score(cldf, cluster_labels)</span>
<span id="cb108-20"><a href="#cb108-20"></a>    text <span class="op">=</span> text <span class="op">+</span> [<span class="ss">f"For k=</span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> the average silhouette_score is: </span><span class="sc">{</span>silhouette_avg<span class="sc">:6.4f}</span><span class="ss">"</span>]</span>
<span id="cb108-21"><a href="#cb108-21"></a>    </span>
<span id="cb108-22"><a href="#cb108-22"></a>    <span class="co"># Calculate the silhouette values</span></span>
<span id="cb108-23"><a href="#cb108-23"></a>    sample_silhouette_values <span class="op">=</span> silhouette_samples(cldf, cluster_labels)</span>
<span id="cb108-24"><a href="#cb108-24"></a>    </span>
<span id="cb108-25"><a href="#cb108-25"></a>    <span class="co">#############</span></span>
<span id="cb108-26"><a href="#cb108-26"></a>    <span class="co"># Create a subplot with 1 row and 2 columns</span></span>
<span id="cb108-27"><a href="#cb108-27"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb108-28"><a href="#cb108-28"></a>    fig.set_size_inches(<span class="dv">9</span>, <span class="dv">5</span>)</span>
<span id="cb108-29"><a href="#cb108-29"></a></span>
<span id="cb108-30"><a href="#cb108-30"></a>    <span class="co"># The 1st subplot is the silhouette plot</span></span>
<span id="cb108-31"><a href="#cb108-31"></a>    <span class="co"># The silhouette coefficient can range from -1, 1</span></span>
<span id="cb108-32"><a href="#cb108-32"></a>    ax1.set_xlim([<span class="op">-</span><span class="fl">1.0</span>, <span class="fl">1.0</span>]) <span class="co"># Changed from -0.1, 1</span></span>
<span id="cb108-33"><a href="#cb108-33"></a>    </span>
<span id="cb108-34"><a href="#cb108-34"></a>    <span class="co"># The (n_clusters+1)*10 is for inserting blank space between silhouette</span></span>
<span id="cb108-35"><a href="#cb108-35"></a>    <span class="co"># plots of individual clusters, to demarcate them clearly.</span></span>
<span id="cb108-36"><a href="#cb108-36"></a>    ax1.set_ylim([<span class="dv">0</span>, cldf.shape[<span class="dv">0</span>] <span class="op">+</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> <span class="dv">10</span>])</span>
<span id="cb108-37"><a href="#cb108-37"></a>    </span>
<span id="cb108-38"><a href="#cb108-38"></a>    y_lower <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb108-39"><a href="#cb108-39"></a>    </span>
<span id="cb108-40"><a href="#cb108-40"></a>    <span class="co"># For each of the clusters...</span></span>
<span id="cb108-41"><a href="#cb108-41"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb108-42"><a href="#cb108-42"></a>        <span class="co"># Aggregate the silhouette scores for samples belonging to</span></span>
<span id="cb108-43"><a href="#cb108-43"></a>        <span class="co"># cluster i, and sort them</span></span>
<span id="cb108-44"><a href="#cb108-44"></a>        ith_cluster_silhouette_values <span class="op">=</span> <span class="op">\</span></span>
<span id="cb108-45"><a href="#cb108-45"></a>            sample_silhouette_values[cluster_labels <span class="op">==</span> i]</span>
<span id="cb108-46"><a href="#cb108-46"></a></span>
<span id="cb108-47"><a href="#cb108-47"></a>        ith_cluster_silhouette_values.sort()</span>
<span id="cb108-48"><a href="#cb108-48"></a></span>
<span id="cb108-49"><a href="#cb108-49"></a>        size_cluster_i <span class="op">=</span> ith_cluster_silhouette_values.shape[<span class="dv">0</span>]</span>
<span id="cb108-50"><a href="#cb108-50"></a>        y_upper <span class="op">=</span> y_lower <span class="op">+</span> size_cluster_i</span>
<span id="cb108-51"><a href="#cb108-51"></a>        </span>
<span id="cb108-52"><a href="#cb108-52"></a>        <span class="co"># Set the color ramp</span></span>
<span id="cb108-53"><a href="#cb108-53"></a>        <span class="co">#cmap  = cm.get_cmap("Spectral")</span></span>
<span id="cb108-54"><a href="#cb108-54"></a>        color <span class="op">=</span> plt.cm.Spectral(i<span class="op">/</span>k)</span>
<span id="cb108-55"><a href="#cb108-55"></a>        ax1.fill_betweenx(np.arange(y_lower, y_upper),</span>
<span id="cb108-56"><a href="#cb108-56"></a>                          <span class="dv">0</span>, ith_cluster_silhouette_values,</span>
<span id="cb108-57"><a href="#cb108-57"></a>                          facecolor<span class="op">=</span>color, edgecolor<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb108-58"><a href="#cb108-58"></a></span>
<span id="cb108-59"><a href="#cb108-59"></a>        <span class="co"># Label the silhouette plots with their cluster numbers at the middle</span></span>
<span id="cb108-60"><a href="#cb108-60"></a>        ax1.text(<span class="op">-</span><span class="fl">0.05</span>, y_lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> size_cluster_i, <span class="bu">str</span>(i))</span>
<span id="cb108-61"><a href="#cb108-61"></a></span>
<span id="cb108-62"><a href="#cb108-62"></a>        <span class="co"># Compute the new y_lower for next plot</span></span>
<span id="cb108-63"><a href="#cb108-63"></a>        y_lower <span class="op">=</span> y_upper <span class="op">+</span> <span class="dv">10</span>  <span class="co"># 10 for the 0 samples</span></span>
<span id="cb108-64"><a href="#cb108-64"></a></span>
<span id="cb108-65"><a href="#cb108-65"></a>    ax1.set_title(<span class="st">"The silhouette plot for the clusters."</span>)</span>
<span id="cb108-66"><a href="#cb108-66"></a>    ax1.set_xlabel(<span class="st">"The silhouette coefficient values"</span>)</span>
<span id="cb108-67"><a href="#cb108-67"></a>    ax1.set_ylabel(<span class="st">"Cluster label"</span>)</span>
<span id="cb108-68"><a href="#cb108-68"></a></span>
<span id="cb108-69"><a href="#cb108-69"></a>    <span class="co"># The vertical line for average silhouette score of all the values</span></span>
<span id="cb108-70"><a href="#cb108-70"></a>    ax1.axvline(x<span class="op">=</span>silhouette_avg, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb108-71"><a href="#cb108-71"></a></span>
<span id="cb108-72"><a href="#cb108-72"></a>    ax1.set_yticks([])  <span class="co"># Clear the yaxis labels / ticks</span></span>
<span id="cb108-73"><a href="#cb108-73"></a>    ax1.set_xticks(np.arange(<span class="op">-</span><span class="fl">1.0</span>, <span class="fl">1.1</span>, <span class="fl">0.2</span>)) <span class="co"># Was: [-0.1, 0, 0.2, 0.4, 0.6, 0.8, 1]</span></span>
<span id="cb108-74"><a href="#cb108-74"></a></span>
<span id="cb108-75"><a href="#cb108-75"></a>    <span class="co"># 2nd Plot showing the actual clusters formed --</span></span>
<span id="cb108-76"><a href="#cb108-76"></a>    <span class="co"># we can only do this for the first two dimensions</span></span>
<span id="cb108-77"><a href="#cb108-77"></a>    <span class="co"># so we may not see fully what is causing the </span></span>
<span id="cb108-78"><a href="#cb108-78"></a>    <span class="co"># resulting assignment</span></span>
<span id="cb108-79"><a href="#cb108-79"></a>    colors <span class="op">=</span> plt.cm.Spectral(cluster_labels.astype(<span class="bu">float</span>) <span class="op">/</span> k)</span>
<span id="cb108-80"><a href="#cb108-80"></a>    ax2.scatter(cldf[cldf.columns[<span class="dv">0</span>]], cldf[cldf.columns[<span class="dv">1</span>]], marker<span class="op">=</span><span class="st">'.'</span>, s<span class="op">=</span><span class="dv">30</span>, lw<span class="op">=</span><span class="dv">0</span>, alpha<span class="op">=</span><span class="fl">0.7</span>,</span>
<span id="cb108-81"><a href="#cb108-81"></a>                c<span class="op">=</span>colors)</span>
<span id="cb108-82"><a href="#cb108-82"></a></span>
<span id="cb108-83"><a href="#cb108-83"></a>    <span class="co"># Labeling the clusters</span></span>
<span id="cb108-84"><a href="#cb108-84"></a>    centers <span class="op">=</span> clusterer.cluster_centers_</span>
<span id="cb108-85"><a href="#cb108-85"></a>    </span>
<span id="cb108-86"><a href="#cb108-86"></a>    <span class="co"># Draw white circles at cluster centers</span></span>
<span id="cb108-87"><a href="#cb108-87"></a>    ax2.scatter(centers[:, <span class="dv">0</span>], centers[:, <span class="dv">1</span>],</span>
<span id="cb108-88"><a href="#cb108-88"></a>                marker<span class="op">=</span><span class="st">'o'</span>, c<span class="op">=</span><span class="st">"white"</span>, alpha<span class="op">=</span><span class="dv">1</span>, s<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb108-89"><a href="#cb108-89"></a></span>
<span id="cb108-90"><a href="#cb108-90"></a>    <span class="cf">for</span> i, c <span class="kw">in</span> <span class="bu">enumerate</span>(centers):</span>
<span id="cb108-91"><a href="#cb108-91"></a>        ax2.scatter(c[<span class="dv">0</span>], c[<span class="dv">1</span>], marker<span class="op">=</span><span class="st">'$</span><span class="sc">%d</span><span class="st">$'</span> <span class="op">%</span> i, alpha<span class="op">=</span><span class="dv">1</span>, s<span class="op">=</span><span class="dv">50</span>)</span>
<span id="cb108-92"><a href="#cb108-92"></a></span>
<span id="cb108-93"><a href="#cb108-93"></a>    ax2.set_title(<span class="st">"Visualization of the clustered data"</span>)</span>
<span id="cb108-94"><a href="#cb108-94"></a>    ax2.set_xlabel(<span class="st">"Feature space for the 1st feature"</span>)</span>
<span id="cb108-95"><a href="#cb108-95"></a>    ax2.set_ylabel(<span class="st">"Feature space for the 2nd feature"</span>)</span>
<span id="cb108-96"><a href="#cb108-96"></a></span>
<span id="cb108-97"><a href="#cb108-97"></a>    plt.suptitle((<span class="st">"Silhouette analysis for KMeans clustering on sample data "</span></span>
<span id="cb108-98"><a href="#cb108-98"></a>                  <span class="st">"with n_clusters = </span><span class="sc">%d</span><span class="st">"</span> <span class="op">%</span> k),</span>
<span id="cb108-99"><a href="#cb108-99"></a>                 fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb108-100"><a href="#cb108-100"></a></span>
<span id="cb108-101"><a href="#cb108-101"></a>    plt.show()</span>
<span id="cb108-102"><a href="#cb108-102"></a></span>
<span id="cb108-103"><a href="#cb108-103"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>.join(text))    </span>
<span id="cb108-104"><a href="#cb108-104"></a></span>
<span id="cb108-105"><a href="#cb108-105"></a><span class="kw">del</span>(cldf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="interpreting-the-results" class="level4">
<h4 class="anchored">Interpreting the Results</h4>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>STOP. Make sure that you understand how the silhouette plot and value work, and why your results may diverge from mine.</p>
<p>:::</p>
<p>We can use the largest average silhouette score to determine the â€˜naturalâ€™ number of clusters in the data, but that thatâ€™s only if we donâ€™t have any kind of underlying <em>theory</em>, other <em>empirical evidence</em>, or even just a <em>reason</em> for choosing a different valueâ€¦ Again, weâ€™re now getting in areas where <em>your judgement</em> and your ability to <em>communicate your rationale</em> to readers is the key thing.</p>
<section id="final-clustering" class="level4">
<h4 class="anchored" data-anchor-id="final-clustering">Final Clustering</h4>
<p>Letâ€™s repeat the clustering process <em>one more time</em> using the silhouette score as a guide and then map it.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1"></a><span class="co">#| scrolled: true</span></span>
<span id="cb109-2"><a href="#cb109-2"></a>c_nm <span class="op">=</span> <span class="st">'KMeans'</span></span>
<span id="cb109-3"><a href="#cb109-3"></a><span class="co"># Quick sanity check in case something hasn't</span></span>
<span id="cb109-4"><a href="#cb109-4"></a><span class="co"># run successfully -- these muck up k-means</span></span>
<span id="cb109-5"><a href="#cb109-5"></a>cldf <span class="op">=</span> df.drop(<span class="bu">list</span>(df.columns[df.isnull().<span class="bu">any</span>().values].values), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb109-6"><a href="#cb109-6"></a></span>
<span id="cb109-7"><a href="#cb109-7"></a>k_pref <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb109-8"><a href="#cb109-8"></a>kmeans <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k_pref, n_init<span class="op">=</span><span class="dv">75</span>, random_state<span class="op">=</span><span class="dv">42</span>).fit(cldf)</span>
<span id="cb109-9"><a href="#cb109-9"></a></span>
<span id="cb109-10"><a href="#cb109-10"></a><span class="co"># Convert to a series</span></span>
<span id="cb109-11"><a href="#cb109-11"></a>s <span class="op">=</span> pd.Series(kmeans.labels_, index<span class="op">=</span>cldf.index, name<span class="op">=</span>c_nm)</span>
<span id="cb109-12"><a href="#cb109-12"></a></span>
<span id="cb109-13"><a href="#cb109-13"></a><span class="co"># We do this for plotting</span></span>
<span id="cb109-14"><a href="#cb109-14"></a>cldf[c_nm] <span class="op">=</span> s</span>
<span id="cb109-15"><a href="#cb109-15"></a></span>
<span id="cb109-16"><a href="#cb109-16"></a><span class="co"># We do this to keep track of the results</span></span>
<span id="cb109-17"><a href="#cb109-17"></a>result_set<span class="op">=</span>add_2_rs(s)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="mapping-results" class="level4">
<h4 class="anchored" data-anchor-id="mapping-results">Mapping Results</h4>
<div class="sourceCode" id="cb110"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1"></a>cgdf <span class="op">=</span> gdf.join(cldf, how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb110-2"><a href="#cb110-2"></a></span>
<span id="cb110-3"><a href="#cb110-3"></a>breaks <span class="op">=</span> np.arange(<span class="dv">0</span>,cldf[c_nm].<span class="bu">max</span>()<span class="op">+</span><span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb110-4"><a href="#cb110-4"></a>cmap   <span class="op">=</span> default_cmap(<span class="bu">len</span>(breaks))</span>
<span id="cb110-5"><a href="#cb110-5"></a></span>
<span id="cb110-6"><a href="#cb110-6"></a>norm    <span class="op">=</span> mpl.colors.BoundaryNorm(breaks, cmap.N)</span>
<span id="cb110-7"><a href="#cb110-7"></a></span>
<span id="cb110-8"><a href="#cb110-8"></a>fig, ax <span class="op">=</span> plt_ldn()</span>
<span id="cb110-9"><a href="#cb110-9"></a>fig.suptitle(<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss"> Results (k=</span><span class="sc">{</span>k_pref<span class="sc">}</span><span class="ss">)"</span>, fontsize<span class="op">=</span><span class="dv">20</span>, y<span class="op">=</span><span class="fl">0.92</span>)</span>
<span id="cb110-10"><a href="#cb110-10"></a>cgdf.plot(column<span class="op">=</span>c_nm, ax<span class="op">=</span>ax, cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm, linewidth<span class="op">=</span><span class="dv">0</span>, zorder<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb110-11"><a href="#cb110-11"></a></span>
<span id="cb110-12"><a href="#cb110-12"></a>add_colorbar(ax.collections[<span class="op">-</span><span class="dv">1</span>], ax, cmap, norm, breaks)</span>
<span id="cb110-13"><a href="#cb110-13"></a></span>
<span id="cb110-14"><a href="#cb110-14"></a>plt.savefig(os.path.join(o_dir,<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>k_pref<span class="sc">}</span><span class="ss">.png"</span>), dpi<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb110-15"><a href="#cb110-15"></a><span class="kw">del</span>(cgdf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To make sense of whether this is a â€˜goodâ€™ result, you might want to visit <a href="http://datashine.org.uk/#table=QS607EW&amp;col=QS607EW0050&amp;ramp=RdYlGn&amp;layers=BTTT&amp;zoom=10&amp;lon=-0.1751&amp;lat=51.4863">datashine</a> or think back to last year when we examined the NS-SeC data.</p>
<p>You could also think of ways of plotting how these groups differ. For instanceâ€¦</p>
</section>
<section id="representative-centroids" class="level4">
<h4 class="anchored" data-anchor-id="representative-centroids">â€˜Representativeâ€™ Centroids</h4>
<p>To get a sense of how these clusters differ we can try to extract â€˜representativeâ€™ centroids (mid-points of the multi-dimensional cloud that constitutes a cluster). In the case of <em>k</em>-means this will work quite will since the clusters are explicitly built around mean centroids. Thereâ€™s also a <em>k</em>-medoids clustering approach built around the median centroid.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1"></a>centroids <span class="op">=</span> <span class="va">None</span></span>
<span id="cb111-2"><a href="#cb111-2"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">sorted</span>(cldf[c_nm].unique()):</span>
<span id="cb111-3"><a href="#cb111-3"></a>    <span class="bu">print</span>(<span class="ss">f"Processing cluster </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb111-4"><a href="#cb111-4"></a></span>
<span id="cb111-5"><a href="#cb111-5"></a>    clsoas <span class="op">=</span> cldf[cldf[c_nm]<span class="op">==</span>k]</span>
<span id="cb111-6"><a href="#cb111-6"></a>    <span class="cf">if</span> centroids <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb111-7"><a href="#cb111-7"></a>        centroids <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>clsoas.columns.values)</span>
<span id="cb111-8"><a href="#cb111-8"></a>    centroids <span class="op">=</span> centroids.append(clsoas.mean(), ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb111-9"><a href="#cb111-9"></a></span>
<span id="cb111-10"><a href="#cb111-10"></a>odf <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">'Variable'</span>,<span class="st">'Cluster'</span>,<span class="st">'Std. Value'</span>])</span>
<span id="cb111-11"><a href="#cb111-11"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(centroids.index)):</span>
<span id="cb111-12"><a href="#cb111-12"></a>    row <span class="op">=</span> centroids.iloc[i,:]</span>
<span id="cb111-13"><a href="#cb111-13"></a>    c_index <span class="op">=</span> <span class="bu">list</span>(centroids.columns.values).index(c_nm)</span>
<span id="cb111-14"><a href="#cb111-14"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,c_index):</span>
<span id="cb111-15"><a href="#cb111-15"></a>        d <span class="op">=</span> {<span class="st">'Variable'</span>:centroids.columns[c], <span class="st">'Cluster'</span>:row[c_index], <span class="st">'Std. Value'</span>:row[c]}</span>
<span id="cb111-16"><a href="#cb111-16"></a>        odf <span class="op">=</span> odf.append(d, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb111-17"><a href="#cb111-17"></a></span>
<span id="cb111-18"><a href="#cb111-18"></a>g <span class="op">=</span> sns.FacetGrid(odf, col<span class="op">=</span><span class="st">"Variable"</span>, col_wrap<span class="op">=</span><span class="dv">3</span>, height<span class="op">=</span><span class="dv">3</span>, aspect<span class="op">=</span><span class="fl">1.5</span>, margin_titles<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb111-19"><a href="#cb111-19"></a>g <span class="op">=</span> g.<span class="bu">map</span>(plt.plot, <span class="st">"Cluster"</span>, <span class="st">"Std. Value"</span>, marker<span class="op">=</span><span class="st">"."</span>)</span>
<span id="cb111-20"><a href="#cb111-20"></a></span>
<span id="cb111-21"><a href="#cb111-21"></a><span class="kw">del</span>(odf, centroids, cldf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="dbscan" class="level3">
<h3 class="anchored">DBScan</h3>
<p>Of course, as weâ€™ve said above <em>k</em>-means is just one way of clustering, DBScan is another. Unlike <em>k</em>-means, we donâ€™t need to specify the number of clusters in advance. Which sounds great, but we still need to specify <em>other</em> parameters (typically, these are known as <em>hyperparameters</em> because they are about specifying parameters that help the aglorithm to find the right solutionâ€¦ or final set of parameters!) and these can have a huge impact on our results!</p>
<section id="importing-the-library-1" class="level4">
<h4 class="anchored" data-anchor-id="importing-the-library-1">Importing the Library</h4>
<div class="sourceCode" id="cb112"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> DBSCAN</span>
<span id="cb112-2"><a href="#cb112-2"></a><span class="co">#?DSCAN</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="find-a-reasonable-value-for-epsilon" class="level4">
<h4 class="anchored" data-anchor-id="find-a-reasonable-value-for-epsilon">Find a Reasonable Value for Epsilon</h4>
<p>Before we an use DBSCAN itâ€™s useful to find a good value for Epsilon. We can <a href="https://towardsdatascience.com/machine-learning-clustering-dbscan-determine-the-optimal-value-for-epsilon-eps-python-example-3100091cfbc">look for the point of maximum â€˜curvatureâ€™</a> in a nearest neigbhours plot. Which seems to be in the vicinity of 0.55. Tips on selecting <code>min_pts</code> can be <a href="https://towardsdatascience.com/how-dbscan-works-and-why-should-i-use-it-443b4a191c80">found here</a>.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1"></a><span class="co"># Quick sanity check in case something hasn't</span></span>
<span id="cb113-2"><a href="#cb113-2"></a><span class="co"># run successfully -- these muck up k-means</span></span>
<span id="cb113-3"><a href="#cb113-3"></a>cldf <span class="op">=</span> df.drop(<span class="bu">list</span>(df.columns[df.isnull().<span class="bu">any</span>().values].values), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb113-4"><a href="#cb113-4"></a></span>
<span id="cb113-5"><a href="#cb113-5"></a>neigh <span class="op">=</span> NearestNeighbors(n_neighbors<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb113-6"><a href="#cb113-6"></a>nbrs <span class="op">=</span> neigh.fit(cldf)</span>
<span id="cb113-7"><a href="#cb113-7"></a>distances, indices <span class="op">=</span> nbrs.kneighbors(cldf)</span>
<span id="cb113-8"><a href="#cb113-8"></a></span>
<span id="cb113-9"><a href="#cb113-9"></a>distances <span class="op">=</span> np.sort(distances, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb113-10"><a href="#cb113-10"></a>distances <span class="op">=</span> distances[:,<span class="dv">1</span>]</span>
<span id="cb113-11"><a href="#cb113-11"></a>plt.plot(distances)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="exploration" class="level4">
<h4 class="anchored">Exploration</h4>
<p>There are two values that need to be specified: <code>eps</code> and <code>min_samples</code>. Both seem to be set largely by trial and error. Itâ€™s easiest to set <code>min_samples</code> first since that sets a floor for your cluster size and then <code>eps</code> is basically a distance metric that governs how far away something can be from a cluster and still be considered part of that cluster.</p>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>WARNING. This next step may take quite a lot of time since we are iterating through many, many values of Epsilon to explore how the clustering result changes and how well this matches up with (or doesnâ€™t) the graph above.</p>
<p>:::</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1"></a>c_nm <span class="op">=</span> <span class="st">'DBSCAN'</span></span>
<span id="cb114-2"><a href="#cb114-2"></a></span>
<span id="cb114-3"><a href="#cb114-3"></a><span class="co"># Quick sanity check in case something hasn't</span></span>
<span id="cb114-4"><a href="#cb114-4"></a><span class="co"># run successfully -- these muck up k-means</span></span>
<span id="cb114-5"><a href="#cb114-5"></a>cldf <span class="op">=</span> df.drop(<span class="bu">list</span>(df.columns[df.isnull().<span class="bu">any</span>().values].values), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-6"><a href="#cb114-6"></a></span>
<span id="cb114-7"><a href="#cb114-7"></a><span class="co"># Make numeric display a bit neater</span></span>
<span id="cb114-8"><a href="#cb114-8"></a>pd.set_option(<span class="st">'display.float_format'</span>, <span class="kw">lambda</span> x: <span class="st">'</span><span class="sc">{:,.4f}</span><span class="st">'</span>.<span class="bu">format</span>(x))</span>
<span id="cb114-9"><a href="#cb114-9"></a></span>
<span id="cb114-10"><a href="#cb114-10"></a><span class="co"># There's an argument for making min_samples = len(df.columns)+1</span></span>
<span id="cb114-11"><a href="#cb114-11"></a></span>
<span id="cb114-12"><a href="#cb114-12"></a>el  <span class="op">=</span> []</span>
<span id="cb114-13"><a href="#cb114-13"></a></span>
<span id="cb114-14"><a href="#cb114-14"></a>max_clusters  <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb114-15"><a href="#cb114-15"></a>cluster_count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb114-16"><a href="#cb114-16"></a></span>
<span id="cb114-17"><a href="#cb114-17"></a>iters <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb114-18"><a href="#cb114-18"></a></span>
<span id="cb114-19"><a href="#cb114-19"></a><span class="cf">for</span> e <span class="kw">in</span> np.arange(<span class="fl">0.15</span>, <span class="fl">1.55</span>, <span class="fl">0.01</span>):</span>
<span id="cb114-20"><a href="#cb114-20"></a>    </span>
<span id="cb114-21"><a href="#cb114-21"></a>    <span class="cf">if</span> iters <span class="op">%</span> <span class="dv">25</span><span class="op">==</span><span class="dv">0</span>: <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>iters<span class="sc">}</span><span class="ss"> epsilons explored."</span>) </span>
<span id="cb114-22"><a href="#cb114-22"></a>    </span>
<span id="cb114-23"><a href="#cb114-23"></a>    <span class="co"># Run the clustering</span></span>
<span id="cb114-24"><a href="#cb114-24"></a>    dbs <span class="op">=</span> DBSCAN(eps<span class="op">=</span>e, min_samples<span class="op">=</span><span class="dv">12</span>, n_jobs<span class="op">=-</span><span class="dv">1</span>).fit(cldf.values)</span>
<span id="cb114-25"><a href="#cb114-25"></a>    </span>
<span id="cb114-26"><a href="#cb114-26"></a>    <span class="co"># See how we did</span></span>
<span id="cb114-27"><a href="#cb114-27"></a>    s <span class="op">=</span> pd.Series(dbs.labels_, index<span class="op">=</span>cldf.index, name<span class="op">=</span>c_nm)</span>
<span id="cb114-28"><a href="#cb114-28"></a>    </span>
<span id="cb114-29"><a href="#cb114-29"></a>    row <span class="op">=</span> [e]</span>
<span id="cb114-30"><a href="#cb114-30"></a>    data <span class="op">=</span> s.value_counts()</span>
<span id="cb114-31"><a href="#cb114-31"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">1</span>, max_clusters<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb114-32"><a href="#cb114-32"></a>        <span class="cf">try</span>:</span>
<span id="cb114-33"><a href="#cb114-33"></a>            row.append(data[c])</span>
<span id="cb114-34"><a href="#cb114-34"></a>        <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb114-35"><a href="#cb114-35"></a>            row.append(<span class="va">None</span>)</span>
<span id="cb114-36"><a href="#cb114-36"></a>    </span>
<span id="cb114-37"><a href="#cb114-37"></a>    el.append(row)</span>
<span id="cb114-38"><a href="#cb114-38"></a>    iters<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb114-39"><a href="#cb114-39"></a></span>
<span id="cb114-40"><a href="#cb114-40"></a>edf <span class="op">=</span> pd.DataFrame(el, columns<span class="op">=</span>[<span class="st">'Epsilon'</span>]<span class="op">+</span>[<span class="st">"Cluster "</span> <span class="op">+</span> <span class="bu">str</span>(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="op">-</span><span class="dv">1</span>,max_clusters<span class="op">+</span><span class="dv">1</span>))])</span>
<span id="cb114-41"><a href="#cb114-41"></a>edf.sample(random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb114-42"><a href="#cb114-42"></a></span>
<span id="cb114-43"><a href="#cb114-43"></a><span class="co"># Make numeric display a bit neater</span></span>
<span id="cb114-44"><a href="#cb114-44"></a>pd.set_option(<span class="st">'display.float_format'</span>, <span class="kw">lambda</span> x: <span class="st">'</span><span class="sc">{:,.2f}</span><span class="st">'</span>.<span class="bu">format</span>(x))</span>
<span id="cb114-45"><a href="#cb114-45"></a></span>
<span id="cb114-46"><a href="#cb114-46"></a><span class="bu">print</span>(<span class="st">"Done."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb115"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1"></a>odf <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">'Epsilon'</span>,<span class="st">'Cluster'</span>,<span class="st">'Count'</span>])</span>
<span id="cb115-2"><a href="#cb115-2"></a></span>
<span id="cb115-3"><a href="#cb115-3"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(edf.index)):</span>
<span id="cb115-4"><a href="#cb115-4"></a>    row <span class="op">=</span> edf.iloc[i,:]</span>
<span id="cb115-5"><a href="#cb115-5"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="bu">len</span>(edf.columns.values)):</span>
<span id="cb115-6"><a href="#cb115-6"></a>        <span class="cf">if</span> <span class="kw">not</span> np.isnan(row[c]):</span>
<span id="cb115-7"><a href="#cb115-7"></a>            d <span class="op">=</span> {<span class="st">'Epsilon'</span>:row[<span class="dv">0</span>], <span class="st">'Cluster'</span>:<span class="ss">f"Cluster </span><span class="sc">{</span>c<span class="op">-</span><span class="dv">2</span><span class="sc">}</span><span class="ss">"</span>, <span class="st">'Count'</span>:row[c]}</span>
<span id="cb115-8"><a href="#cb115-8"></a>            odf <span class="op">=</span> odf.append(d, ignore_index<span class="op">=</span><span class="va">True</span>)       </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb116"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1"></a>xmin <span class="op">=</span> odf[odf.Cluster<span class="op">==</span><span class="st">'Cluster 0'</span>].Epsilon.<span class="bu">min</span>()</span>
<span id="cb116-2"><a href="#cb116-2"></a>xmax <span class="op">=</span> odf[(odf.Cluster<span class="op">==</span><span class="st">'Cluster -1'</span>) <span class="op">&amp;</span> (odf.Count <span class="op">&lt;</span> cldf.shape[<span class="dv">0</span>]<span class="op">/</span><span class="dv">5</span>)].Epsilon.<span class="bu">min</span>()</span>
<span id="cb116-3"><a href="#cb116-3"></a></span>
<span id="cb116-4"><a href="#cb116-4"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>))</span>
<span id="cb116-5"><a href="#cb116-5"></a>ax.set_xlim([xmin,xmax])</span>
<span id="cb116-6"><a href="#cb116-6"></a>sns.lineplot(data<span class="op">=</span>odf, x<span class="op">=</span><span class="st">'Epsilon'</span>, y<span class="op">=</span><span class="st">'Count'</span>, hue<span class="op">=</span><span class="st">'Cluster'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="final-clustering-1" class="level4">
<h4 class="anchored" data-anchor-id="final-clustering-1">Final Clustering</h4>
<div class="sourceCode" id="cb117"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1"></a>e <span class="op">=</span> <span class="fl">0.835</span></span>
<span id="cb117-2"><a href="#cb117-2"></a>dbs <span class="op">=</span> DBSCAN(eps<span class="op">=</span>e, min_samples<span class="op">=</span><span class="dv">12</span>, n_jobs<span class="op">=-</span><span class="dv">1</span>).fit(cldf.values)</span>
<span id="cb117-3"><a href="#cb117-3"></a>s <span class="op">=</span> pd.Series(dbs.labels_, index<span class="op">=</span>cldf.index, name<span class="op">=</span>c_nm)</span>
<span id="cb117-4"><a href="#cb117-4"></a>cldf[c_nm] <span class="op">=</span> s</span>
<span id="cb117-5"><a href="#cb117-5"></a>result_set<span class="op">=</span>add_2_rs(s)</span>
<span id="cb117-6"><a href="#cb117-6"></a><span class="bu">print</span>(s.value_counts())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb118"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1"></a>cgdf <span class="op">=</span> gdf.join(cldf, how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb118-2"><a href="#cb118-2"></a></span>
<span id="cb118-3"><a href="#cb118-3"></a>breaks <span class="op">=</span> np.arange(cldf[c_nm].<span class="bu">min</span>(),cldf[c_nm].<span class="bu">max</span>()<span class="op">+</span><span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb118-4"><a href="#cb118-4"></a>cmap   <span class="op">=</span> default_cmap(<span class="bu">len</span>(breaks), outliers<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb118-5"><a href="#cb118-5"></a>norm   <span class="op">=</span> mpl.colors.BoundaryNorm(breaks, cmap.N, clip<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb118-6"><a href="#cb118-6"></a></span>
<span id="cb118-7"><a href="#cb118-7"></a>fig, ax <span class="op">=</span> plt_ldn()</span>
<span id="cb118-8"><a href="#cb118-8"></a>fig.suptitle(<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss"> Results"</span>, fontsize<span class="op">=</span><span class="dv">20</span>, y<span class="op">=</span><span class="fl">0.92</span>)</span>
<span id="cb118-9"><a href="#cb118-9"></a></span>
<span id="cb118-10"><a href="#cb118-10"></a>cgdf.plot(column<span class="op">=</span>c_nm, ax<span class="op">=</span>ax, cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm, linewidth<span class="op">=</span><span class="dv">0</span>, zorder<span class="op">=</span><span class="dv">0</span>, legend<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb118-11"><a href="#cb118-11"></a></span>
<span id="cb118-12"><a href="#cb118-12"></a>add_colorbar(ax.collections[<span class="op">-</span><span class="dv">1</span>], ax, cmap, norm, breaks, outliers<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb118-13"><a href="#cb118-13"></a></span>
<span id="cb118-14"><a href="#cb118-14"></a>plt.savefig(os.path.join(o_dir,<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss">.png"</span>), dpi<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb118-15"><a href="#cb118-15"></a><span class="kw">del</span>(cgdf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="representative-centroids-1" class="level4">
<h4 class="anchored" data-anchor-id="representative-centroids-1">â€˜Representativeâ€™ Centroids</h4>
<p>To get a sense of how these clusters differ we can try to extract â€˜representativeâ€™ centroids (mid-points of the multi-dimensional cloud that constitutes a cluster). For algorithms other than <em>k</em>-means it may be better to use medians than means.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1"></a>centroids <span class="op">=</span> <span class="va">None</span></span>
<span id="cb119-2"><a href="#cb119-2"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">sorted</span>(cldf[c_nm].unique()):</span>
<span id="cb119-3"><a href="#cb119-3"></a>    <span class="bu">print</span>(<span class="ss">f"Processing cluster </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb119-4"><a href="#cb119-4"></a></span>
<span id="cb119-5"><a href="#cb119-5"></a>    clsoas <span class="op">=</span> cldf[cldf[c_nm]<span class="op">==</span>k]</span>
<span id="cb119-6"><a href="#cb119-6"></a>    <span class="cf">if</span> centroids <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb119-7"><a href="#cb119-7"></a>        centroids <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>clsoas.columns.values)</span>
<span id="cb119-8"><a href="#cb119-8"></a>    centroids <span class="op">=</span> centroids.append(clsoas.mean(), ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb119-9"><a href="#cb119-9"></a></span>
<span id="cb119-10"><a href="#cb119-10"></a>odf <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">'Variable'</span>,<span class="st">'Cluster'</span>,<span class="st">'Std. Value'</span>])</span>
<span id="cb119-11"><a href="#cb119-11"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(centroids.index)):</span>
<span id="cb119-12"><a href="#cb119-12"></a>    row <span class="op">=</span> centroids.iloc[i,:]</span>
<span id="cb119-13"><a href="#cb119-13"></a>    c_index <span class="op">=</span> <span class="bu">list</span>(centroids.columns.values).index(c_nm)</span>
<span id="cb119-14"><a href="#cb119-14"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,c_index):</span>
<span id="cb119-15"><a href="#cb119-15"></a>        d <span class="op">=</span> {<span class="st">'Variable'</span>:centroids.columns[c], <span class="st">'Cluster'</span>:row[c_index], <span class="st">'Std. Value'</span>:row[c]}</span>
<span id="cb119-16"><a href="#cb119-16"></a>        odf <span class="op">=</span> odf.append(d, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb119-17"><a href="#cb119-17"></a></span>
<span id="cb119-18"><a href="#cb119-18"></a><span class="co"># Drop outliers</span></span>
<span id="cb119-19"><a href="#cb119-19"></a>odf <span class="op">=</span> odf[odf.Cluster <span class="op">&gt;=</span> <span class="dv">0</span>]</span>
<span id="cb119-20"><a href="#cb119-20"></a></span>
<span id="cb119-21"><a href="#cb119-21"></a>g <span class="op">=</span> sns.FacetGrid(odf, col<span class="op">=</span><span class="st">"Variable"</span>, col_wrap<span class="op">=</span><span class="dv">3</span>, height<span class="op">=</span><span class="dv">3</span>, aspect<span class="op">=</span><span class="fl">1.5</span>, margin_titles<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb119-22"><a href="#cb119-22"></a>g <span class="op">=</span> g.<span class="bu">map</span>(plt.plot, <span class="st">"Cluster"</span>, <span class="st">"Std. Value"</span>, marker<span class="op">=</span><span class="st">"."</span>)</span>
<span id="cb119-23"><a href="#cb119-23"></a></span>
<span id="cb119-24"><a href="#cb119-24"></a><span class="kw">del</span>(odf, centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="optics-clustering" class="level3">
<h3 class="anchored">OPTICS Clustering</h3>
<p>This is a fairly new addition to <code>sklearn</code> and is similar to DBSCAN in that there are very few (if any) parameters to specify. This means that weâ€™re making fewer assumptions about the nature of any clustering in the data. It also allows us to have outliers that donâ€™t get assigned to <em>any</em> cluster. The focus is mainly on local density, so in some sense itâ€™s more like a geographically aware clustering approach, but applied in the data space, not geographical space.</p>
<section id="importing-the-library-2" class="level4">
<h4 class="anchored" data-anchor-id="importing-the-library-2">Importing the Library</h4>
<div class="sourceCode" id="cb120"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> OPTICS</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="final-clustering-2" class="level4">
<h4 class="anchored">Final Clustering</h4>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>WARNING. This next step may take quite a lot of time since the algorithm is making far fewer assumptions about the structure of the data. On a 2018 MacBook Pro with 16GB of RAM it took about 5 minutes.</p>
<p>:::</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1"></a>c_nm <span class="op">=</span> <span class="st">'Optics'</span></span>
<span id="cb121-2"><a href="#cb121-2"></a></span>
<span id="cb121-3"><a href="#cb121-3"></a><span class="co"># Can try to set this from DBSCAN results</span></span>
<span id="cb121-4"><a href="#cb121-4"></a>e <span class="op">=</span> <span class="fl">0.9850</span></span>
<span id="cb121-5"><a href="#cb121-5"></a></span>
<span id="cb121-6"><a href="#cb121-6"></a><span class="co"># Quick sanity check in case something hasn't</span></span>
<span id="cb121-7"><a href="#cb121-7"></a><span class="co"># run successfully -- these muck up k-means</span></span>
<span id="cb121-8"><a href="#cb121-8"></a>cldf <span class="op">=</span> df.drop(<span class="bu">list</span>(df.columns[df.isnull().<span class="bu">any</span>().values].values), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb121-9"><a href="#cb121-9"></a></span>
<span id="cb121-10"><a href="#cb121-10"></a><span class="im">import</span> math</span>
<span id="cb121-11"><a href="#cb121-11"></a></span>
<span id="cb121-12"><a href="#cb121-12"></a><span class="co"># Run the clustering</span></span>
<span id="cb121-13"><a href="#cb121-13"></a>opt <span class="op">=</span> OPTICS(min_samples<span class="op">=</span><span class="bu">len</span>(df.columns)<span class="op">+</span><span class="dv">1</span>, max_eps<span class="op">=</span>math.ceil(e <span class="op">*</span> <span class="dv">100</span>)<span class="op">/</span><span class="dv">100</span>, n_jobs<span class="op">=-</span><span class="dv">1</span>).fit(cldf.values)</span>
<span id="cb121-14"><a href="#cb121-14"></a></span>
<span id="cb121-15"><a href="#cb121-15"></a><span class="co"># See how we did</span></span>
<span id="cb121-16"><a href="#cb121-16"></a>s <span class="op">=</span> pd.Series(opt.labels_, index<span class="op">=</span>cldf.index, name<span class="op">=</span>c_nm)</span>
<span id="cb121-17"><a href="#cb121-17"></a>cldf[c_nm] <span class="op">=</span> s</span>
<span id="cb121-18"><a href="#cb121-18"></a>result_set<span class="op">=</span>add_2_rs(s)</span>
<span id="cb121-19"><a href="#cb121-19"></a></span>
<span id="cb121-20"><a href="#cb121-20"></a><span class="co"># Distribution</span></span>
<span id="cb121-21"><a href="#cb121-21"></a><span class="bu">print</span>(s.value_counts())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="mapping-clustering-results" class="level4">
<h4 class="anchored">Mapping Clustering Results</h4>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>WARNING. My sense is that these results are a bit rubbish: the majority of items are assigned to <em>one cluster</em>??? Iâ€™ve tried PCA on the standardised data and that made little difference. This should also have worked <em>better</em> but it seems that a small number of LSOAs are so utterly different that the more sophisticated clustering algorithm effectively â€˜chokesâ€™ on them.</p>
<p>:::</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1"></a>cgdf <span class="op">=</span> gdf.join(cldf, how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb122-2"><a href="#cb122-2"></a></span>
<span id="cb122-3"><a href="#cb122-3"></a>breaks <span class="op">=</span> np.arange(cldf[c_nm].<span class="bu">min</span>(),cldf[c_nm].<span class="bu">max</span>()<span class="op">+</span><span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb122-4"><a href="#cb122-4"></a>cmap   <span class="op">=</span> default_cmap(<span class="bu">len</span>(breaks), outliers<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb122-5"><a href="#cb122-5"></a>norm   <span class="op">=</span> mpl.colors.BoundaryNorm(breaks, cmap.N, clip<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb122-6"><a href="#cb122-6"></a></span>
<span id="cb122-7"><a href="#cb122-7"></a>fig, ax <span class="op">=</span> plt_ldn()</span>
<span id="cb122-8"><a href="#cb122-8"></a>fig.suptitle(<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss"> Results"</span>, fontsize<span class="op">=</span><span class="dv">20</span>, y<span class="op">=</span><span class="fl">0.92</span>)</span>
<span id="cb122-9"><a href="#cb122-9"></a></span>
<span id="cb122-10"><a href="#cb122-10"></a>cgdf.plot(column<span class="op">=</span>c_nm, ax<span class="op">=</span>ax, cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm, linewidth<span class="op">=</span><span class="dv">0</span>, zorder<span class="op">=</span><span class="dv">0</span>, legend<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb122-11"><a href="#cb122-11"></a></span>
<span id="cb122-12"><a href="#cb122-12"></a>add_colorbar(ax.collections[<span class="op">-</span><span class="dv">1</span>], ax, cmap, norm, breaks, outliers<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb122-13"><a href="#cb122-13"></a></span>
<span id="cb122-14"><a href="#cb122-14"></a>plt.savefig(os.path.join(o_dir,<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss">.png"</span>), dpi<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb122-15"><a href="#cb122-15"></a><span class="kw">del</span>(cgdf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="representative-centroids-2" class="level4">
<h4 class="anchored">â€˜Representativeâ€™ Centroids</h4>
<p>To get a sense of how these clusters differ we can try to extract â€˜representativeâ€™ centroids (mid-points of the multi-dimensional cloud that constitutes a cluster). For algorithms other than <em>k</em>-Means it may be better to use medians, not means.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1"></a>centroids <span class="op">=</span> <span class="va">None</span></span>
<span id="cb123-2"><a href="#cb123-2"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">sorted</span>(cldf[c_nm].unique()):</span>
<span id="cb123-3"><a href="#cb123-3"></a>    <span class="bu">print</span>(<span class="ss">f"Processing cluster </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb123-4"><a href="#cb123-4"></a></span>
<span id="cb123-5"><a href="#cb123-5"></a>    clsoas <span class="op">=</span> cldf[cldf[c_nm]<span class="op">==</span>k]</span>
<span id="cb123-6"><a href="#cb123-6"></a>    <span class="cf">if</span> centroids <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb123-7"><a href="#cb123-7"></a>        centroids <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>clsoas.columns.values)</span>
<span id="cb123-8"><a href="#cb123-8"></a>    centroids <span class="op">=</span> centroids.append(clsoas.mean(), ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb123-9"><a href="#cb123-9"></a></span>
<span id="cb123-10"><a href="#cb123-10"></a>odf <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">'Variable'</span>,<span class="st">'Cluster'</span>,<span class="st">'Std. Value'</span>])</span>
<span id="cb123-11"><a href="#cb123-11"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(centroids.index)):</span>
<span id="cb123-12"><a href="#cb123-12"></a>    row <span class="op">=</span> centroids.iloc[i,:]</span>
<span id="cb123-13"><a href="#cb123-13"></a>    c_index <span class="op">=</span> <span class="bu">list</span>(centroids.columns.values).index(c_nm)</span>
<span id="cb123-14"><a href="#cb123-14"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,c_index):</span>
<span id="cb123-15"><a href="#cb123-15"></a>        d <span class="op">=</span> {<span class="st">'Variable'</span>:centroids.columns[c], <span class="st">'Cluster'</span>:row[c_index], <span class="st">'Std. Value'</span>:row[c]}</span>
<span id="cb123-16"><a href="#cb123-16"></a>        odf <span class="op">=</span> odf.append(d, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb123-17"><a href="#cb123-17"></a></span>
<span id="cb123-18"><a href="#cb123-18"></a>g <span class="op">=</span> sns.FacetGrid(odf, col<span class="op">=</span><span class="st">"Variable"</span>, col_wrap<span class="op">=</span><span class="dv">3</span>, height<span class="op">=</span><span class="dv">3</span>, aspect<span class="op">=</span><span class="fl">1.5</span>, margin_titles<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb123-19"><a href="#cb123-19"></a>g <span class="op">=</span> g.<span class="bu">map</span>(plt.plot, <span class="st">"Cluster"</span>, <span class="st">"Std. Value"</span>, marker<span class="op">=</span><span class="st">"."</span>)</span>
<span id="cb123-20"><a href="#cb123-20"></a></span>
<span id="cb123-21"><a href="#cb123-21"></a><span class="kw">del</span>(odf, centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>STOP. Aside from the fact that we should probably reduce the number of dimensions on which weâ€™re clustering, what about the process of selecting variables (a.k.a. feature selection) might have led to the result that our results are a bit crap? <em>Hint: how did we decide what to keep and what to drop, and is this a robust approach?</em></p>
<p>:::</p>
<section id="hdbscan" class="level3">
<h3 class="anchored" data-anchor-id="hdbscan">HDBSCAN</h3>
<p>Not implemented, but you could give it a try after installing the package:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb124-1"><a href="#cb124-1"></a><span class="ex">conda</span> activate <span class="op">&lt;</span>your environment name here<span class="op">&gt;</span></span>
<span id="cb124-2"><a href="#cb124-2"></a><span class="ex">conda</span> install <span class="at">-c</span> conda-forge sklearn-contrib-hdbscan</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Then it should be something like:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1"></a><span class="im">import</span> hdbscan</span>
<span id="cb125-2"><a href="#cb125-2"></a>clusterer <span class="op">=</span> hdbscan.HDBSCAN()</span>
<span id="cb125-3"><a href="#cb125-3"></a><span class="co"># HDBSCAN(algorithm='best', alpha=1.0, approx_min_span_tree=True,</span></span>
<span id="cb125-4"><a href="#cb125-4"></a><span class="co">#    gen_min_span_tree=False, leaf_size=40, memory=Memory(cachedir=None),</span></span>
<span id="cb125-5"><a href="#cb125-5"></a><span class="co">#    metric='euclidean', min_cluster_size=5, min_samples=None, p=None)</span></span>
<span id="cb125-6"><a href="#cb125-6"></a>clusterer.fit(<span class="op">&lt;</span>data<span class="op">&gt;</span>)</span>
<span id="cb125-7"><a href="#cb125-7"></a>clusterer.labels_</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="hierarchical-clustering" class="level3">
<h3 class="anchored" data-anchor-id="hierarchical-clustering">Hierarchical Clustering</h3>
<p>Probably not appropriate as it tends to be confused by noise.</p>
</section>
<section id="self-organising-maps" class="level3">
<h3 class="anchored">Self-Organising Maps</h3>
<p>SOMs offer a third type of clustering algorithm. They are a relatively â€˜simpleâ€™ type of neural network in which the â€˜mapâ€™ (of the SOM) adjusts to the data: weâ€™re going to see how this works over the next few code blocks, but the main thing is that, unlike the above approaches, SOMs build a 2D map of a higher-dimensional space and use this as a mechanism for subsequently clustering the raw data. In this sense there is a conceptual link between SOMs and PCA or tSNE (another form of dimensionality reduction).</p>
<section id="reinstalling-sompy" class="level4">
<h4 class="anchored">(Re)Installing SOMPY</h4>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>WARNING. The maintainers of the main SOMPY library are fairly inactive, so weâ€™ve had to write our own version that fixes a few Python3 bugs, but this means that it canâ€™t be installed the â€˜usualâ€™ way without also having Git installed. Consequently, I have left the output from SOMPY in place so that you can see what it will produce <em>even if you cannot successfully install SOMPY during this practical</em></p>
<div class=".">
<p>To work out if there is an issue, check to see if the <code>import</code> statement below gives you errors:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1"></a><span class="im">from</span> sompy.sompy <span class="im">import</span> SOMFactory</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If this import has failed with a warning about being unable to find SOM or something similar, then you will need to <em>re</em>-install SOMPY using a fork that I created on our Kings GSA GitHub account. For <em>that</em> to work, you will need to ensure that you have <code>git</code> installed.</p>
<p>If the following Terminal command (which should also work in the Windows Terminal) does not give you an error then <code>git</code> is already installed:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb127-1"><a href="#cb127-1"></a>git --version</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To install <code>git</code> on a Mac is fairly simple. Again, from the Terminal issue the following command:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb128-1"><a href="#cb128-1"></a>xcode-select --install</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This installation may take some time over eduroam since there is a lot to download.</p>
<p>Once thatâ€™s complete, you can move on to installing SOMPY from our fork. On a Mac this is done on the Terminal with:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb129-1"><a href="#cb129-1"></a>conda activate &lt;your kernel name here&gt;</span>
<span id="cb129-2"><a href="#cb129-2"></a>pip install -e git+git://github.com/kingsgeocomp/SOMPY.git#egg=SOMPY</span>
<span id="cb129-3"><a href="#cb129-3"></a>conda deactivate</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On Windows you probably drop the <code>conda</code> part of the command.</p>
<section id="training-the-som" class="level4">
<h4 class="anchored" data-anchor-id="training-the-som">Training the SOM</h4>
<p>We are going to actually train the SOM using the input data. This is where you specify the input parameters that have the main effect on the clustering results.</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1"></a><span class="im">from</span> sompy.sompy <span class="im">import</span> SOMFactory</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb131"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1"></a>c_nm <span class="op">=</span> <span class="st">'SOM'</span></span>
<span id="cb131-2"><a href="#cb131-2"></a></span>
<span id="cb131-3"><a href="#cb131-3"></a><span class="co"># Quick sanity check in case something hasn't</span></span>
<span id="cb131-4"><a href="#cb131-4"></a><span class="co"># run successfully -- these muck up k-means</span></span>
<span id="cb131-5"><a href="#cb131-5"></a>cldf <span class="op">=</span> df.drop(<span class="bu">list</span>(df.columns[df.isnull().<span class="bu">any</span>().values].values), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb131-6"><a href="#cb131-6"></a></span>
<span id="cb131-7"><a href="#cb131-7"></a>sm <span class="op">=</span> SOMFactory().build(</span>
<span id="cb131-8"><a href="#cb131-8"></a>    cldf.values, mapsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">15</span>),</span>
<span id="cb131-9"><a href="#cb131-9"></a>    normalization<span class="op">=</span><span class="st">'var'</span>, initialization<span class="op">=</span><span class="st">'random'</span>, component_names<span class="op">=</span>cldf.columns.values)</span>
<span id="cb131-10"><a href="#cb131-10"></a>sm.train(n_job<span class="op">=</span><span class="dv">4</span>, verbose<span class="op">=</span><span class="va">False</span>, train_rough_len<span class="op">=</span><span class="dv">2</span>, train_finetune_len<span class="op">=</span><span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>How good is the fit?</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1"></a>topographic_error  <span class="op">=</span> sm.calculate_topographic_error()</span>
<span id="cb132-2"><a href="#cb132-2"></a>quantization_error <span class="op">=</span> np.mean(sm._bmu[<span class="dv">1</span>])</span>
<span id="cb132-3"><a href="#cb132-3"></a><span class="bu">print</span>(<span class="st">"Topographic error = </span><span class="sc">{0:0.5f}</span><span class="st">; Quantization error = </span><span class="sc">{1:0.5f}</span><span class="st">"</span>.<span class="bu">format</span>(topographic_error, quantization_error))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>How do the results look?</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1"></a><span class="im">from</span> sompy.visualization.mapview <span class="im">import</span> View2D</span>
<span id="cb133-2"><a href="#cb133-2"></a>view2D <span class="op">=</span> View2D(<span class="dv">10</span>, <span class="dv">10</span>, <span class="st">"rand data"</span>, text_size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb133-3"><a href="#cb133-3"></a>view2D.show(sm, col_sz<span class="op">=</span><span class="dv">4</span>, which_dim<span class="op">=</span><span class="st">"all"</span>, denormalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb133-4"><a href="#cb133-4"></a>plt.savefig(os.path.join(o_dir, <span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss">-Map.png"</span>), dpi<span class="op">=</span><span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="heres-what-i-got" class="level4">
<h4 class="anchored">Hereâ€™s What I Got</h4>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>WARNING. These are the results from the approach that is closest to the one outlined in <em>Geocomputation</em>.</p>
<p>:::</p>
<p><img src="https://github.com/kingsgeocomp/applied_gsa/raw/master/img/SOM-Map.png" alt="SOM Clustering Results" width="800"></p>
<p>How many data points were assigned to each BMU?</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1"></a><span class="im">from</span> sompy.visualization.bmuhits <span class="im">import</span> BmuHitsView</span>
<span id="cb134-2"><a href="#cb134-2"></a>vhts <span class="op">=</span> BmuHitsView(<span class="dv">15</span>, <span class="dv">15</span>, <span class="st">"Hits Map"</span>, text_size<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb134-3"><a href="#cb134-3"></a>vhts.show(sm, anotate<span class="op">=</span><span class="va">True</span>, onlyzeros<span class="op">=</span><span class="va">False</span>, labelsize<span class="op">=</span><span class="dv">9</span>, cmap<span class="op">=</span><span class="st">"plasma"</span>, logaritmic<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb134-4"><a href="#cb134-4"></a>plt.savefig(os.path.join(o_dir,<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss">-BMU Hit View.png"</span>), dpi<span class="op">=</span><span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="bmu-hit-map" class="level4">
<h4 class="anchored">BMU Hit Map</h4>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>WARNING. These are the results from the approach that is closest to the one outlined in <em>Geocomputation</em>.</p>
<p>:::</p>
<p><img src="https://github.com/kingsgeocomp/applied_gsa/raw/master/img/SOM-BMU Hit View.png" alt="SOM Heat Map Results" width="800"></p>
<p>How many clusters do we want and where are they on the map?</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1"></a><span class="im">from</span> sompy.visualization.hitmap <span class="im">import</span> HitMapView</span>
<span id="cb135-2"><a href="#cb135-2"></a></span>
<span id="cb135-3"><a href="#cb135-3"></a>k_val <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb135-4"><a href="#cb135-4"></a>sm.cluster(k_val)</span>
<span id="cb135-5"><a href="#cb135-5"></a>hits  <span class="op">=</span> HitMapView(<span class="dv">15</span>, <span class="dv">15</span>, <span class="st">"Clustering"</span>, text_size<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb135-6"><a href="#cb135-6"></a>a     <span class="op">=</span> hits.show(sm)</span>
<span id="cb135-7"><a href="#cb135-7"></a>plt.savefig(os.path.join(o_dir,<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss">-Hit Map View.png"</span>), dpi<span class="op">=</span><span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="clustering-the-bmus" class="level4">
<h4 class="anchored">Clustering the BMUs</h4>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>WARNING. These are the results from the approach that is closest to the one outlined in <em>Geocomputation</em>.</p>
<p>:::</p>
<p><img src="https://github.com/kingsgeocomp/applied_gsa/raw/master/img/SOM-Hit Map View.png" alt="SOM Clustering Results" width="800"></p>
<p>Finally, letâ€™s get the cluster results and map them back on to the data points:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1"></a><span class="co"># Get the labels for each BMU</span></span>
<span id="cb136-2"><a href="#cb136-2"></a><span class="co"># in the SOM (15 * 10 neurons)</span></span>
<span id="cb136-3"><a href="#cb136-3"></a>clabs <span class="op">=</span> sm.cluster_labels</span>
<span id="cb136-4"><a href="#cb136-4"></a></span>
<span id="cb136-5"><a href="#cb136-5"></a><span class="cf">try</span>:</span>
<span id="cb136-6"><a href="#cb136-6"></a>    cldf.drop(c_nm,inplace<span class="op">=</span><span class="va">True</span>,axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb136-7"><a href="#cb136-7"></a><span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb136-8"><a href="#cb136-8"></a>    <span class="cf">pass</span></span>
<span id="cb136-9"><a href="#cb136-9"></a></span>
<span id="cb136-10"><a href="#cb136-10"></a><span class="co"># Project the data on to the SOM</span></span>
<span id="cb136-11"><a href="#cb136-11"></a><span class="co"># so that we get the BMU for each</span></span>
<span id="cb136-12"><a href="#cb136-12"></a><span class="co"># of the original data points</span></span>
<span id="cb136-13"><a href="#cb136-13"></a>bmus  <span class="op">=</span> sm.project_data(cldf.values)</span>
<span id="cb136-14"><a href="#cb136-14"></a></span>
<span id="cb136-15"><a href="#cb136-15"></a><span class="co"># Turn the BMUs into cluster labels</span></span>
<span id="cb136-16"><a href="#cb136-16"></a><span class="co"># and append to the data frame</span></span>
<span id="cb136-17"><a href="#cb136-17"></a>s <span class="op">=</span> pd.Series(clabs[bmus], index<span class="op">=</span>cldf.index, name<span class="op">=</span>c_nm)</span>
<span id="cb136-18"><a href="#cb136-18"></a></span>
<span id="cb136-19"><a href="#cb136-19"></a>cldf[c_nm] <span class="op">=</span> s</span>
<span id="cb136-20"><a href="#cb136-20"></a>result_set <span class="op">=</span> add_2_rs(s)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb137"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1"></a>cgdf <span class="op">=</span> gdf.join(cldf, how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb137-2"><a href="#cb137-2"></a></span>
<span id="cb137-3"><a href="#cb137-3"></a>breaks <span class="op">=</span> np.arange(cldf[c_nm].<span class="bu">min</span>(),cldf[c_nm].<span class="bu">max</span>()<span class="op">+</span><span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb137-4"><a href="#cb137-4"></a>cmap   <span class="op">=</span> default_cmap(<span class="bu">len</span>(breaks))</span>
<span id="cb137-5"><a href="#cb137-5"></a>norm   <span class="op">=</span> mpl.colors.BoundaryNorm(breaks, cmap.N, clip<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb137-6"><a href="#cb137-6"></a></span>
<span id="cb137-7"><a href="#cb137-7"></a>fig, ax <span class="op">=</span> plt_ldn()</span>
<span id="cb137-8"><a href="#cb137-8"></a>fig.suptitle(<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss"> Results"</span>, fontsize<span class="op">=</span><span class="dv">20</span>, y<span class="op">=</span><span class="fl">0.92</span>)</span>
<span id="cb137-9"><a href="#cb137-9"></a></span>
<span id="cb137-10"><a href="#cb137-10"></a>cgdf.plot(column<span class="op">=</span>c_nm, ax<span class="op">=</span>ax, cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm, linewidth<span class="op">=</span><span class="dv">0</span>, zorder<span class="op">=</span><span class="dv">0</span>, legend<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb137-11"><a href="#cb137-11"></a></span>
<span id="cb137-12"><a href="#cb137-12"></a>add_colorbar(ax.collections[<span class="op">-</span><span class="dv">1</span>], ax, cmap, norm, breaks)</span>
<span id="cb137-13"><a href="#cb137-13"></a></span>
<span id="cb137-14"><a href="#cb137-14"></a>plt.savefig(os.path.join(o_dir,<span class="ss">f"</span><span class="sc">{</span>c_nm<span class="sc">}</span><span class="ss">.png"</span>), dpi<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb137-15"><a href="#cb137-15"></a><span class="kw">del</span>(cgdf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="result" class="level4">
<h4 class="anchored">Result!</h4>
<div style="padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red">
<p>WARNING. These are the results from the approach that is closest to the one outlined in <em>Geocomputation</em>.</p>
<p>:::</p>
<p><img src="https://github.com/kingsgeocomp/applied_gsa/raw/master/img/SOM.png" alt="SOM Clustering Results Mapped" width="800"></p>
<section id="representative-centroids-3" class="level4">
<h4 class="anchored" data-anchor-id="representative-centroids-3">Representative Centroids</h4>
<div class="sourceCode" id="cb138"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1"></a>centroids <span class="op">=</span> <span class="va">None</span></span>
<span id="cb138-2"><a href="#cb138-2"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">sorted</span>(cldf[c_nm].unique()):</span>
<span id="cb138-3"><a href="#cb138-3"></a>    <span class="bu">print</span>(<span class="ss">f"Processing cluster </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb138-4"><a href="#cb138-4"></a></span>
<span id="cb138-5"><a href="#cb138-5"></a>    clsoas <span class="op">=</span> cldf[cldf[c_nm]<span class="op">==</span>k]</span>
<span id="cb138-6"><a href="#cb138-6"></a>    <span class="cf">if</span> centroids <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb138-7"><a href="#cb138-7"></a>        centroids <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>clsoas.columns.values)</span>
<span id="cb138-8"><a href="#cb138-8"></a>    centroids <span class="op">=</span> centroids.append(clsoas.mean(), ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb138-9"><a href="#cb138-9"></a></span>
<span id="cb138-10"><a href="#cb138-10"></a>odf <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">'Variable'</span>,<span class="st">'Cluster'</span>,<span class="st">'Std. Value'</span>])</span>
<span id="cb138-11"><a href="#cb138-11"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(centroids.index)):</span>
<span id="cb138-12"><a href="#cb138-12"></a>    row <span class="op">=</span> centroids.iloc[i,:]</span>
<span id="cb138-13"><a href="#cb138-13"></a>    c_index <span class="op">=</span> <span class="bu">list</span>(centroids.columns.values).index(c_nm)</span>
<span id="cb138-14"><a href="#cb138-14"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,c_index):</span>
<span id="cb138-15"><a href="#cb138-15"></a>        d <span class="op">=</span> {<span class="st">'Variable'</span>:centroids.columns[c], <span class="st">'Cluster'</span>:row[c_index], <span class="st">'Std. Value'</span>:row[c]}</span>
<span id="cb138-16"><a href="#cb138-16"></a>        odf <span class="op">=</span> odf.append(d, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb138-17"><a href="#cb138-17"></a></span>
<span id="cb138-18"><a href="#cb138-18"></a>g <span class="op">=</span> sns.FacetGrid(odf, col<span class="op">=</span><span class="st">"Variable"</span>, col_wrap<span class="op">=</span><span class="dv">3</span>, height<span class="op">=</span><span class="dv">3</span>, aspect<span class="op">=</span><span class="fl">1.5</span>, margin_titles<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb138-19"><a href="#cb138-19"></a>g <span class="op">=</span> g.<span class="bu">map</span>(plt.plot, <span class="st">"Cluster"</span>, <span class="st">"Std. Value"</span>, marker<span class="op">=</span><span class="st">"."</span>)</span>
<span id="cb138-20"><a href="#cb138-20"></a></span>
<span id="cb138-21"><a href="#cb138-21"></a><span class="kw">del</span>(odf, centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="wrap-up" class="level2">
<h2 class="anchored" data-anchor-id="wrap-up">Wrap-Up</h2>
<ul>
<li>Find the appropriate eps value: <a href="https://nbviewer.jupyter.org/github/pysal/pointpats/blob/master/notebooks/distance_statistics.ipynb#Nearest-Neighbor-Distance-Functions">Nearest Neighbour Distance Functions</a> or <a href="https://nbviewer.jupyter.org/github/pysal/pointpats/blob/master/notebooks/distance_statistics.ipynb#Interevent-Distance-Functions">Interevent Distance Functions</a></li>
<li><a href="https://darribas.org/gds_course/content/bH/lab_H.html#clusters-of-points">Clustering Points</a></li>
<li><a href="https://darribas.org/gds_course/content/bG/lab_G.html#regionalization-algorithms">Regionalisation algorithms with Aglomerative Clustering</a></li>
</ul>
<p>Youâ€™ve reached the end, youâ€™re doneâ€¦</p>
<p>Er, no. This is barely scratching the surface! Iâ€™d suggest that you go back through the above code and do three things: 1. Add a lot more comments to the code to ensure that really have understood what is going on. 2. Try playing with some of the parameters (e.g.&nbsp;my thresholds for skew, or non-normality) and seeing how your results change. 3. Try outputting additional plots that will help you to understand the <em>quality</em> of your clustering results (e.g.&nbsp;what <em>is</em> the makeup of cluster 1? Or 6? What has it picked up? What names would I give these clsuters?).</p>
<p>If all of that seems like a lot of work then why not learn a bit more about machine learning before calling it a day?</p>
<p>See: <a href="http://www.slideshare.net/BenjaminBengfort/introduction-to-machine-learning-with-scikitlearn">Introduction to Machine Learning with Scikit-Learn</a>.</p>


</section>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
</div>
</section>
</section>
</div>
</section>
</div>
</section>
</div>
</section>
</section>
</div>
</section>
</section>
</div>
</section>
</div>
</section>
</section>
</div>
</section>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 2022â€“2025, Jon Reades</p>
</div>   
    <div class="nav-footer-center">
<p><img src="../../img/logo/logo_only_sm.png" height="25"> Foundations of Spatial Data Science</p>
<div class="toc-actions"><ul><li><a href="https://github.com/jreades/fsds/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jreades/fsds">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://bsky.app/profile/jreades.bsky.social/">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>